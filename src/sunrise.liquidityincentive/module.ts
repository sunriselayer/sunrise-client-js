// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryGaugeResponse } from "./types/sunrise/liquidityincentive/query";
import { Params } from "./types/sunrise/liquidityincentive/params";
import { QueryEpochsResponse } from "./types/sunrise/liquidityincentive/query";
import { MsgCollectVoteRewardsResponse } from "./types/sunrise/liquidityincentive/tx";
import { GenesisState } from "./types/sunrise/liquidityincentive/genesis";
import { QueryVotesResponse } from "./types/sunrise/liquidityincentive/query";
import { Vote } from "./types/sunrise/liquidityincentive/gauge";
import { MsgCollectVoteRewards } from "./types/sunrise/liquidityincentive/tx";
import { QueryParamsRequest } from "./types/sunrise/liquidityincentive/query";
import { QueryVoteRequest } from "./types/sunrise/liquidityincentive/query";
import { EventSetVote } from "./types/sunrise/liquidityincentive/events";
import { PoolWeight } from "./types/sunrise/liquidityincentive/gauge";
import { MsgVoteGaugeResponse } from "./types/sunrise/liquidityincentive/tx";
import { Epoch } from "./types/sunrise/liquidityincentive/epoch";
import { QueryGaugeRequest } from "./types/sunrise/liquidityincentive/query";
import { QueryVoteResponse } from "./types/sunrise/liquidityincentive/query";
import { QueryVotesRequest } from "./types/sunrise/liquidityincentive/query";
import { QueryGaugesResponse } from "./types/sunrise/liquidityincentive/query";
import { QueryEpochResponse } from "./types/sunrise/liquidityincentive/query";
import { QueryEpochsRequest } from "./types/sunrise/liquidityincentive/query";
import { QueryGaugesRequest } from "./types/sunrise/liquidityincentive/query";
import { Gauge } from "./types/sunrise/liquidityincentive/gauge";
import { MsgVoteGauge } from "./types/sunrise/liquidityincentive/tx";
import { MsgUpdateParams } from "./types/sunrise/liquidityincentive/tx";
import { MsgUpdateParamsResponse } from "./types/sunrise/liquidityincentive/tx";
import { QueryParamsResponse } from "./types/sunrise/liquidityincentive/query";
import { QueryEpochRequest } from "./types/sunrise/liquidityincentive/query";


export { QueryGaugeResponse, Params, QueryEpochsResponse, MsgCollectVoteRewardsResponse, GenesisState, QueryVotesResponse, Vote, MsgCollectVoteRewards, QueryParamsRequest, QueryVoteRequest, EventSetVote, PoolWeight, MsgVoteGaugeResponse, Epoch, QueryGaugeRequest, QueryVoteResponse, QueryVotesRequest, QueryGaugesResponse, QueryEpochResponse, QueryEpochsRequest, QueryGaugesRequest, Gauge, MsgVoteGauge, MsgUpdateParams, MsgUpdateParamsResponse, QueryParamsResponse, QueryEpochRequest };

type sendQueryGaugeResponseParams = {
  value: QueryGaugeResponse,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryEpochsResponseParams = {
  value: QueryEpochsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCollectVoteRewardsResponseParams = {
  value: MsgCollectVoteRewardsResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendQueryVotesResponseParams = {
  value: QueryVotesResponse,
  fee?: StdFee,
  memo?: string
};

type sendVoteParams = {
  value: Vote,
  fee?: StdFee,
  memo?: string
};

type sendMsgCollectVoteRewardsParams = {
  value: MsgCollectVoteRewards,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryVoteRequestParams = {
  value: QueryVoteRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventSetVoteParams = {
  value: EventSetVote,
  fee?: StdFee,
  memo?: string
};

type sendPoolWeightParams = {
  value: PoolWeight,
  fee?: StdFee,
  memo?: string
};

type sendMsgVoteGaugeResponseParams = {
  value: MsgVoteGaugeResponse,
  fee?: StdFee,
  memo?: string
};

type sendEpochParams = {
  value: Epoch,
  fee?: StdFee,
  memo?: string
};

type sendQueryGaugeRequestParams = {
  value: QueryGaugeRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryVoteResponseParams = {
  value: QueryVoteResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryVotesRequestParams = {
  value: QueryVotesRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGaugesResponseParams = {
  value: QueryGaugesResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryEpochResponseParams = {
  value: QueryEpochResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryEpochsRequestParams = {
  value: QueryEpochsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGaugesRequestParams = {
  value: QueryGaugesRequest,
  fee?: StdFee,
  memo?: string
};

type sendGaugeParams = {
  value: Gauge,
  fee?: StdFee,
  memo?: string
};

type sendMsgVoteGaugeParams = {
  value: MsgVoteGauge,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryEpochRequestParams = {
  value: QueryEpochRequest,
  fee?: StdFee,
  memo?: string
};


type queryGaugeResponseParams = {
  value: QueryGaugeResponse,
};

type paramsParams = {
  value: Params,
};

type queryEpochsResponseParams = {
  value: QueryEpochsResponse,
};

type msgCollectVoteRewardsResponseParams = {
  value: MsgCollectVoteRewardsResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type queryVotesResponseParams = {
  value: QueryVotesResponse,
};

type voteParams = {
  value: Vote,
};

type msgCollectVoteRewardsParams = {
  value: MsgCollectVoteRewards,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryVoteRequestParams = {
  value: QueryVoteRequest,
};

type eventSetVoteParams = {
  value: EventSetVote,
};

type poolWeightParams = {
  value: PoolWeight,
};

type msgVoteGaugeResponseParams = {
  value: MsgVoteGaugeResponse,
};

type epochParams = {
  value: Epoch,
};

type queryGaugeRequestParams = {
  value: QueryGaugeRequest,
};

type queryVoteResponseParams = {
  value: QueryVoteResponse,
};

type queryVotesRequestParams = {
  value: QueryVotesRequest,
};

type queryGaugesResponseParams = {
  value: QueryGaugesResponse,
};

type queryEpochResponseParams = {
  value: QueryEpochResponse,
};

type queryEpochsRequestParams = {
  value: QueryEpochsRequest,
};

type queryGaugesRequestParams = {
  value: QueryGaugesRequest,
};

type gaugeParams = {
  value: Gauge,
};

type msgVoteGaugeParams = {
  value: MsgVoteGauge,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryEpochRequestParams = {
  value: QueryEpochRequest,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryGaugeResponse({ value, fee, memo }: sendQueryGaugeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGaugeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGaugeResponse({ value: QueryGaugeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGaugeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryEpochsResponse({ value, fee, memo }: sendQueryEpochsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryEpochsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryEpochsResponse({ value: QueryEpochsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryEpochsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCollectVoteRewardsResponse({ value, fee, memo }: sendMsgCollectVoteRewardsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCollectVoteRewardsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCollectVoteRewardsResponse({ value: MsgCollectVoteRewardsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCollectVoteRewardsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryVotesResponse({ value, fee, memo }: sendQueryVotesResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryVotesResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryVotesResponse({ value: QueryVotesResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryVotesResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendVote({ value, fee, memo }: sendVoteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendVote: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.vote({ value: Vote.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendVote: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCollectVoteRewards({ value, fee, memo }: sendMsgCollectVoteRewardsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCollectVoteRewards: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCollectVoteRewards({ value: MsgCollectVoteRewards.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCollectVoteRewards: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryVoteRequest({ value, fee, memo }: sendQueryVoteRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryVoteRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryVoteRequest({ value: QueryVoteRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryVoteRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSetVote({ value, fee, memo }: sendEventSetVoteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSetVote: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSetVote({ value: EventSetVote.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSetVote: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPoolWeight({ value, fee, memo }: sendPoolWeightParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPoolWeight: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.poolWeight({ value: PoolWeight.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPoolWeight: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgVoteGaugeResponse({ value, fee, memo }: sendMsgVoteGaugeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgVoteGaugeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgVoteGaugeResponse({ value: MsgVoteGaugeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgVoteGaugeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEpoch({ value, fee, memo }: sendEpochParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEpoch: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.epoch({ value: Epoch.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEpoch: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGaugeRequest({ value, fee, memo }: sendQueryGaugeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGaugeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGaugeRequest({ value: QueryGaugeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGaugeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryVoteResponse({ value, fee, memo }: sendQueryVoteResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryVoteResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryVoteResponse({ value: QueryVoteResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryVoteResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryVotesRequest({ value, fee, memo }: sendQueryVotesRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryVotesRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryVotesRequest({ value: QueryVotesRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryVotesRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGaugesResponse({ value, fee, memo }: sendQueryGaugesResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGaugesResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGaugesResponse({ value: QueryGaugesResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGaugesResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryEpochResponse({ value, fee, memo }: sendQueryEpochResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryEpochResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryEpochResponse({ value: QueryEpochResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryEpochResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryEpochsRequest({ value, fee, memo }: sendQueryEpochsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryEpochsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryEpochsRequest({ value: QueryEpochsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryEpochsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGaugesRequest({ value, fee, memo }: sendQueryGaugesRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGaugesRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGaugesRequest({ value: QueryGaugesRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGaugesRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGauge({ value, fee, memo }: sendGaugeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGauge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.gauge({ value: Gauge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGauge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgVoteGauge({ value, fee, memo }: sendMsgVoteGaugeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgVoteGauge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgVoteGauge({ value: MsgVoteGauge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgVoteGauge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryEpochRequest({ value, fee, memo }: sendQueryEpochRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryEpochRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryEpochRequest({ value: QueryEpochRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryEpochRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryGaugeResponse({ value }: queryGaugeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryGaugeResponse", value: QueryGaugeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGaugeResponse: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryEpochsResponse({ value }: queryEpochsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryEpochsResponse", value: QueryEpochsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryEpochsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCollectVoteRewardsResponse({ value }: msgCollectVoteRewardsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgCollectVoteRewardsResponse", value: MsgCollectVoteRewardsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCollectVoteRewardsResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		queryVotesResponse({ value }: queryVotesResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryVotesResponse", value: QueryVotesResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryVotesResponse: Could not create message: ' + e.message)
			}
		},
		
		vote({ value }: voteParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.Vote", value: Vote.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Vote: Could not create message: ' + e.message)
			}
		},
		
		msgCollectVoteRewards({ value }: msgCollectVoteRewardsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgCollectVoteRewards", value: MsgCollectVoteRewards.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCollectVoteRewards: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryVoteRequest({ value }: queryVoteRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryVoteRequest", value: QueryVoteRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryVoteRequest: Could not create message: ' + e.message)
			}
		},
		
		eventSetVote({ value }: eventSetVoteParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.EventSetVote", value: EventSetVote.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSetVote: Could not create message: ' + e.message)
			}
		},
		
		poolWeight({ value }: poolWeightParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.PoolWeight", value: PoolWeight.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PoolWeight: Could not create message: ' + e.message)
			}
		},
		
		msgVoteGaugeResponse({ value }: msgVoteGaugeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgVoteGaugeResponse", value: MsgVoteGaugeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgVoteGaugeResponse: Could not create message: ' + e.message)
			}
		},
		
		epoch({ value }: epochParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.Epoch", value: Epoch.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Epoch: Could not create message: ' + e.message)
			}
		},
		
		queryGaugeRequest({ value }: queryGaugeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryGaugeRequest", value: QueryGaugeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGaugeRequest: Could not create message: ' + e.message)
			}
		},
		
		queryVoteResponse({ value }: queryVoteResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryVoteResponse", value: QueryVoteResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryVoteResponse: Could not create message: ' + e.message)
			}
		},
		
		queryVotesRequest({ value }: queryVotesRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryVotesRequest", value: QueryVotesRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryVotesRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGaugesResponse({ value }: queryGaugesResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryGaugesResponse", value: QueryGaugesResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGaugesResponse: Could not create message: ' + e.message)
			}
		},
		
		queryEpochResponse({ value }: queryEpochResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryEpochResponse", value: QueryEpochResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryEpochResponse: Could not create message: ' + e.message)
			}
		},
		
		queryEpochsRequest({ value }: queryEpochsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryEpochsRequest", value: QueryEpochsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryEpochsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGaugesRequest({ value }: queryGaugesRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryGaugesRequest", value: QueryGaugesRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGaugesRequest: Could not create message: ' + e.message)
			}
		},
		
		gauge({ value }: gaugeParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.Gauge", value: Gauge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Gauge: Could not create message: ' + e.message)
			}
		},
		
		msgVoteGauge({ value }: msgVoteGaugeParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgVoteGauge", value: MsgVoteGauge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgVoteGauge: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryEpochRequest({ value }: queryEpochRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquidityincentive.QueryEpochRequest", value: QueryEpochRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryEpochRequest: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SunriseLiquidityincentive: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;