// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgClaimRewards } from "./types/sunrise/liquiditypool/tx";
import { QueryCalculationCreatePositionRequest } from "./types/sunrise/liquiditypool/query";
import { QueryCalculationIncreaseLiquidityRequest } from "./types/sunrise/liquiditypool/query";
import { MsgUpdateParams } from "./types/sunrise/liquiditypool/tx";
import { MsgDecreaseLiquidity } from "./types/sunrise/liquiditypool/tx";
import { MsgDecreaseLiquidityResponse } from "./types/sunrise/liquiditypool/tx";
import { QueryParamsResponse } from "./types/sunrise/liquiditypool/query";
import { QueryPoolRequest } from "./types/sunrise/liquiditypool/query";
import { QueryPoolsRequest } from "./types/sunrise/liquiditypool/query";
import { QueryPositionFeesRequest } from "./types/sunrise/liquiditypool/query";
import { Pool } from "./types/sunrise/liquiditypool/pool";
import { EventCollectFees } from "./types/sunrise/liquiditypool/events";
import { PoolInfo } from "./types/sunrise/liquiditypool/query";
import { QueryPoolResponse } from "./types/sunrise/liquiditypool/query";
import { QueryCalculationCreatePositionResponse } from "./types/sunrise/liquiditypool/query";
import { AccumulatorPosition } from "./types/sunrise/liquiditypool/accumulator";
import { QueryParamsRequest } from "./types/sunrise/liquiditypool/query";
import { EventSetPool } from "./types/sunrise/liquiditypool/events";
import { QueryPositionRequest } from "./types/sunrise/liquiditypool/query";
import { QueryPositionsResponse } from "./types/sunrise/liquiditypool/query";
import { MsgCreatePoolResponse } from "./types/sunrise/liquiditypool/tx";
import { QueryPositionsRequest } from "./types/sunrise/liquiditypool/query";
import { AccumulatorObject } from "./types/sunrise/liquiditypool/accumulator";
import { EventRemovePool } from "./types/sunrise/liquiditypool/events";
import { EventRemovePosition } from "./types/sunrise/liquiditypool/events";
import { QueryPoolsResponse } from "./types/sunrise/liquiditypool/query";
import { QueryPositionResponse } from "./types/sunrise/liquiditypool/query";
import { QueryAddressPositionsRequest } from "./types/sunrise/liquiditypool/query";
import { QueryAddressPositionsResponse } from "./types/sunrise/liquiditypool/query";
import { TickInfo } from "./types/sunrise/liquiditypool/ticker";
import { MsgClaimRewardsResponse } from "./types/sunrise/liquiditypool/tx";
import { GenesisState } from "./types/sunrise/liquiditypool/genesis";
import { MsgIncreaseLiquidity } from "./types/sunrise/liquiditypool/tx";
import { MsgCreatePositionResponse } from "./types/sunrise/liquiditypool/tx";
import { QueryCalculationIncreaseLiquidityResponse } from "./types/sunrise/liquiditypool/query";
import { EventSetPosition } from "./types/sunrise/liquiditypool/events";
import { QueryPositionFeesResponse } from "./types/sunrise/liquiditypool/query";
import { Position } from "./types/sunrise/liquiditypool/position";
import { Params } from "./types/sunrise/liquiditypool/params";
import { QueryPoolPositionsRequest } from "./types/sunrise/liquiditypool/query";
import { QueryPoolPositionsResponse } from "./types/sunrise/liquiditypool/query";
import { EventSwapExactAmountIn } from "./types/sunrise/liquiditypool/events";
import { MsgCreatePool } from "./types/sunrise/liquiditypool/tx";
import { PositionInfo } from "./types/sunrise/liquiditypool/query";
import { MsgCreatePosition } from "./types/sunrise/liquiditypool/tx";
import { MsgUpdateParamsResponse } from "./types/sunrise/liquiditypool/tx";
import { TickParams } from "./types/sunrise/liquiditypool/pool";
import { EventSwapExactAmountOut } from "./types/sunrise/liquiditypool/events";
import { MsgIncreaseLiquidityResponse } from "./types/sunrise/liquiditypool/tx";


export { MsgClaimRewards, QueryCalculationCreatePositionRequest, QueryCalculationIncreaseLiquidityRequest, MsgUpdateParams, MsgDecreaseLiquidity, MsgDecreaseLiquidityResponse, QueryParamsResponse, QueryPoolRequest, QueryPoolsRequest, QueryPositionFeesRequest, Pool, EventCollectFees, PoolInfo, QueryPoolResponse, QueryCalculationCreatePositionResponse, AccumulatorPosition, QueryParamsRequest, EventSetPool, QueryPositionRequest, QueryPositionsResponse, MsgCreatePoolResponse, QueryPositionsRequest, AccumulatorObject, EventRemovePool, EventRemovePosition, QueryPoolsResponse, QueryPositionResponse, QueryAddressPositionsRequest, QueryAddressPositionsResponse, TickInfo, MsgClaimRewardsResponse, GenesisState, MsgIncreaseLiquidity, MsgCreatePositionResponse, QueryCalculationIncreaseLiquidityResponse, EventSetPosition, QueryPositionFeesResponse, Position, Params, QueryPoolPositionsRequest, QueryPoolPositionsResponse, EventSwapExactAmountIn, MsgCreatePool, PositionInfo, MsgCreatePosition, MsgUpdateParamsResponse, TickParams, EventSwapExactAmountOut, MsgIncreaseLiquidityResponse };

type sendMsgClaimRewardsParams = {
  value: MsgClaimRewards,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationCreatePositionRequestParams = {
  value: QueryCalculationCreatePositionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationIncreaseLiquidityRequestParams = {
  value: QueryCalculationIncreaseLiquidityRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgDecreaseLiquidityParams = {
  value: MsgDecreaseLiquidity,
  fee?: StdFee,
  memo?: string
};

type sendMsgDecreaseLiquidityResponseParams = {
  value: MsgDecreaseLiquidityResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolRequestParams = {
  value: QueryPoolRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolsRequestParams = {
  value: QueryPoolsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionFeesRequestParams = {
  value: QueryPositionFeesRequest,
  fee?: StdFee,
  memo?: string
};

type sendPoolParams = {
  value: Pool,
  fee?: StdFee,
  memo?: string
};

type sendEventCollectFeesParams = {
  value: EventCollectFees,
  fee?: StdFee,
  memo?: string
};

type sendPoolInfoParams = {
  value: PoolInfo,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolResponseParams = {
  value: QueryPoolResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationCreatePositionResponseParams = {
  value: QueryCalculationCreatePositionResponse,
  fee?: StdFee,
  memo?: string
};

type sendAccumulatorPositionParams = {
  value: AccumulatorPosition,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventSetPoolParams = {
  value: EventSetPool,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionRequestParams = {
  value: QueryPositionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionsResponseParams = {
  value: QueryPositionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePoolResponseParams = {
  value: MsgCreatePoolResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionsRequestParams = {
  value: QueryPositionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendAccumulatorObjectParams = {
  value: AccumulatorObject,
  fee?: StdFee,
  memo?: string
};

type sendEventRemovePoolParams = {
  value: EventRemovePool,
  fee?: StdFee,
  memo?: string
};

type sendEventRemovePositionParams = {
  value: EventRemovePosition,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolsResponseParams = {
  value: QueryPoolsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionResponseParams = {
  value: QueryPositionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAddressPositionsRequestParams = {
  value: QueryAddressPositionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAddressPositionsResponseParams = {
  value: QueryAddressPositionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendTickInfoParams = {
  value: TickInfo,
  fee?: StdFee,
  memo?: string
};

type sendMsgClaimRewardsResponseParams = {
  value: MsgClaimRewardsResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendMsgIncreaseLiquidityParams = {
  value: MsgIncreaseLiquidity,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePositionResponseParams = {
  value: MsgCreatePositionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationIncreaseLiquidityResponseParams = {
  value: QueryCalculationIncreaseLiquidityResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventSetPositionParams = {
  value: EventSetPosition,
  fee?: StdFee,
  memo?: string
};

type sendQueryPositionFeesResponseParams = {
  value: QueryPositionFeesResponse,
  fee?: StdFee,
  memo?: string
};

type sendPositionParams = {
  value: Position,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolPositionsRequestParams = {
  value: QueryPoolPositionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoolPositionsResponseParams = {
  value: QueryPoolPositionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventSwapExactAmountInParams = {
  value: EventSwapExactAmountIn,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePoolParams = {
  value: MsgCreatePool,
  fee?: StdFee,
  memo?: string
};

type sendPositionInfoParams = {
  value: PositionInfo,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePositionParams = {
  value: MsgCreatePosition,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendTickParamsParams = {
  value: TickParams,
  fee?: StdFee,
  memo?: string
};

type sendEventSwapExactAmountOutParams = {
  value: EventSwapExactAmountOut,
  fee?: StdFee,
  memo?: string
};

type sendMsgIncreaseLiquidityResponseParams = {
  value: MsgIncreaseLiquidityResponse,
  fee?: StdFee,
  memo?: string
};


type msgClaimRewardsParams = {
  value: MsgClaimRewards,
};

type queryCalculationCreatePositionRequestParams = {
  value: QueryCalculationCreatePositionRequest,
};

type queryCalculationIncreaseLiquidityRequestParams = {
  value: QueryCalculationIncreaseLiquidityRequest,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgDecreaseLiquidityParams = {
  value: MsgDecreaseLiquidity,
};

type msgDecreaseLiquidityResponseParams = {
  value: MsgDecreaseLiquidityResponse,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryPoolRequestParams = {
  value: QueryPoolRequest,
};

type queryPoolsRequestParams = {
  value: QueryPoolsRequest,
};

type queryPositionFeesRequestParams = {
  value: QueryPositionFeesRequest,
};

type poolParams = {
  value: Pool,
};

type eventCollectFeesParams = {
  value: EventCollectFees,
};

type poolInfoParams = {
  value: PoolInfo,
};

type queryPoolResponseParams = {
  value: QueryPoolResponse,
};

type queryCalculationCreatePositionResponseParams = {
  value: QueryCalculationCreatePositionResponse,
};

type accumulatorPositionParams = {
  value: AccumulatorPosition,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type eventSetPoolParams = {
  value: EventSetPool,
};

type queryPositionRequestParams = {
  value: QueryPositionRequest,
};

type queryPositionsResponseParams = {
  value: QueryPositionsResponse,
};

type msgCreatePoolResponseParams = {
  value: MsgCreatePoolResponse,
};

type queryPositionsRequestParams = {
  value: QueryPositionsRequest,
};

type accumulatorObjectParams = {
  value: AccumulatorObject,
};

type eventRemovePoolParams = {
  value: EventRemovePool,
};

type eventRemovePositionParams = {
  value: EventRemovePosition,
};

type queryPoolsResponseParams = {
  value: QueryPoolsResponse,
};

type queryPositionResponseParams = {
  value: QueryPositionResponse,
};

type queryAddressPositionsRequestParams = {
  value: QueryAddressPositionsRequest,
};

type queryAddressPositionsResponseParams = {
  value: QueryAddressPositionsResponse,
};

type tickInfoParams = {
  value: TickInfo,
};

type msgClaimRewardsResponseParams = {
  value: MsgClaimRewardsResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type msgIncreaseLiquidityParams = {
  value: MsgIncreaseLiquidity,
};

type msgCreatePositionResponseParams = {
  value: MsgCreatePositionResponse,
};

type queryCalculationIncreaseLiquidityResponseParams = {
  value: QueryCalculationIncreaseLiquidityResponse,
};

type eventSetPositionParams = {
  value: EventSetPosition,
};

type queryPositionFeesResponseParams = {
  value: QueryPositionFeesResponse,
};

type positionParams = {
  value: Position,
};

type paramsParams = {
  value: Params,
};

type queryPoolPositionsRequestParams = {
  value: QueryPoolPositionsRequest,
};

type queryPoolPositionsResponseParams = {
  value: QueryPoolPositionsResponse,
};

type eventSwapExactAmountInParams = {
  value: EventSwapExactAmountIn,
};

type msgCreatePoolParams = {
  value: MsgCreatePool,
};

type positionInfoParams = {
  value: PositionInfo,
};

type msgCreatePositionParams = {
  value: MsgCreatePosition,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type tickParamsParams = {
  value: TickParams,
};

type eventSwapExactAmountOutParams = {
  value: EventSwapExactAmountOut,
};

type msgIncreaseLiquidityResponseParams = {
  value: MsgIncreaseLiquidityResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgClaimRewards({ value, fee, memo }: sendMsgClaimRewardsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgClaimRewards: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgClaimRewards({ value: MsgClaimRewards.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgClaimRewards: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationCreatePositionRequest({ value, fee, memo }: sendQueryCalculationCreatePositionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationCreatePositionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationCreatePositionRequest({ value: QueryCalculationCreatePositionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationCreatePositionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationIncreaseLiquidityRequest({ value, fee, memo }: sendQueryCalculationIncreaseLiquidityRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationIncreaseLiquidityRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationIncreaseLiquidityRequest({ value: QueryCalculationIncreaseLiquidityRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationIncreaseLiquidityRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDecreaseLiquidity({ value, fee, memo }: sendMsgDecreaseLiquidityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDecreaseLiquidity: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDecreaseLiquidity({ value: MsgDecreaseLiquidity.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDecreaseLiquidity: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDecreaseLiquidityResponse({ value, fee, memo }: sendMsgDecreaseLiquidityResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDecreaseLiquidityResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDecreaseLiquidityResponse({ value: MsgDecreaseLiquidityResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDecreaseLiquidityResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolRequest({ value, fee, memo }: sendQueryPoolRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolRequest({ value: QueryPoolRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolsRequest({ value, fee, memo }: sendQueryPoolsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolsRequest({ value: QueryPoolsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionFeesRequest({ value, fee, memo }: sendQueryPositionFeesRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionFeesRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionFeesRequest({ value: QueryPositionFeesRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionFeesRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPool({ value, fee, memo }: sendPoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.pool({ value: Pool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventCollectFees({ value, fee, memo }: sendEventCollectFeesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventCollectFees: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventCollectFees({ value: EventCollectFees.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventCollectFees: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPoolInfo({ value, fee, memo }: sendPoolInfoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPoolInfo: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.poolInfo({ value: PoolInfo.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPoolInfo: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolResponse({ value, fee, memo }: sendQueryPoolResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolResponse({ value: QueryPoolResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationCreatePositionResponse({ value, fee, memo }: sendQueryCalculationCreatePositionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationCreatePositionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationCreatePositionResponse({ value: QueryCalculationCreatePositionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationCreatePositionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAccumulatorPosition({ value, fee, memo }: sendAccumulatorPositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAccumulatorPosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.accumulatorPosition({ value: AccumulatorPosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAccumulatorPosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSetPool({ value, fee, memo }: sendEventSetPoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSetPool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSetPool({ value: EventSetPool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSetPool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionRequest({ value, fee, memo }: sendQueryPositionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionRequest({ value: QueryPositionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionsResponse({ value, fee, memo }: sendQueryPositionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionsResponse({ value: QueryPositionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePoolResponse({ value, fee, memo }: sendMsgCreatePoolResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePoolResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePoolResponse({ value: MsgCreatePoolResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePoolResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionsRequest({ value, fee, memo }: sendQueryPositionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionsRequest({ value: QueryPositionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAccumulatorObject({ value, fee, memo }: sendAccumulatorObjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAccumulatorObject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.accumulatorObject({ value: AccumulatorObject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAccumulatorObject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventRemovePool({ value, fee, memo }: sendEventRemovePoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventRemovePool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventRemovePool({ value: EventRemovePool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventRemovePool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventRemovePosition({ value, fee, memo }: sendEventRemovePositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventRemovePosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventRemovePosition({ value: EventRemovePosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventRemovePosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolsResponse({ value, fee, memo }: sendQueryPoolsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolsResponse({ value: QueryPoolsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionResponse({ value, fee, memo }: sendQueryPositionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionResponse({ value: QueryPositionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAddressPositionsRequest({ value, fee, memo }: sendQueryAddressPositionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAddressPositionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAddressPositionsRequest({ value: QueryAddressPositionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAddressPositionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAddressPositionsResponse({ value, fee, memo }: sendQueryAddressPositionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAddressPositionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAddressPositionsResponse({ value: QueryAddressPositionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAddressPositionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendTickInfo({ value, fee, memo }: sendTickInfoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendTickInfo: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.tickInfo({ value: TickInfo.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendTickInfo: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgClaimRewardsResponse({ value, fee, memo }: sendMsgClaimRewardsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgClaimRewardsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgClaimRewardsResponse({ value: MsgClaimRewardsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgClaimRewardsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgIncreaseLiquidity({ value, fee, memo }: sendMsgIncreaseLiquidityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgIncreaseLiquidity: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgIncreaseLiquidity({ value: MsgIncreaseLiquidity.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgIncreaseLiquidity: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePositionResponse({ value, fee, memo }: sendMsgCreatePositionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePositionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePositionResponse({ value: MsgCreatePositionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePositionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationIncreaseLiquidityResponse({ value, fee, memo }: sendQueryCalculationIncreaseLiquidityResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationIncreaseLiquidityResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationIncreaseLiquidityResponse({ value: QueryCalculationIncreaseLiquidityResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationIncreaseLiquidityResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSetPosition({ value, fee, memo }: sendEventSetPositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSetPosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSetPosition({ value: EventSetPosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSetPosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPositionFeesResponse({ value, fee, memo }: sendQueryPositionFeesResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPositionFeesResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPositionFeesResponse({ value: QueryPositionFeesResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPositionFeesResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPosition({ value, fee, memo }: sendPositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.position({ value: Position.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolPositionsRequest({ value, fee, memo }: sendQueryPoolPositionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolPositionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolPositionsRequest({ value: QueryPoolPositionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolPositionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoolPositionsResponse({ value, fee, memo }: sendQueryPoolPositionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoolPositionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoolPositionsResponse({ value: QueryPoolPositionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoolPositionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSwapExactAmountIn({ value, fee, memo }: sendEventSwapExactAmountInParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSwapExactAmountIn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSwapExactAmountIn({ value: EventSwapExactAmountIn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSwapExactAmountIn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePool({ value, fee, memo }: sendMsgCreatePoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePool({ value: MsgCreatePool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPositionInfo({ value, fee, memo }: sendPositionInfoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPositionInfo: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.positionInfo({ value: PositionInfo.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPositionInfo: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePosition({ value, fee, memo }: sendMsgCreatePositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePosition({ value: MsgCreatePosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendTickParams({ value, fee, memo }: sendTickParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendTickParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.tickParams({ value: TickParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendTickParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSwapExactAmountOut({ value, fee, memo }: sendEventSwapExactAmountOutParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSwapExactAmountOut: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSwapExactAmountOut({ value: EventSwapExactAmountOut.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSwapExactAmountOut: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgIncreaseLiquidityResponse({ value, fee, memo }: sendMsgIncreaseLiquidityResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgIncreaseLiquidityResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgIncreaseLiquidityResponse({ value: MsgIncreaseLiquidityResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgIncreaseLiquidityResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgClaimRewards({ value }: msgClaimRewardsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgClaimRewards", value: MsgClaimRewards.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgClaimRewards: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationCreatePositionRequest({ value }: queryCalculationCreatePositionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryCalculationCreatePositionRequest", value: QueryCalculationCreatePositionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationCreatePositionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationIncreaseLiquidityRequest({ value }: queryCalculationIncreaseLiquidityRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryCalculationIncreaseLiquidityRequest", value: QueryCalculationIncreaseLiquidityRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationIncreaseLiquidityRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgDecreaseLiquidity({ value }: msgDecreaseLiquidityParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgDecreaseLiquidity", value: MsgDecreaseLiquidity.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDecreaseLiquidity: Could not create message: ' + e.message)
			}
		},
		
		msgDecreaseLiquidityResponse({ value }: msgDecreaseLiquidityResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgDecreaseLiquidityResponse", value: MsgDecreaseLiquidityResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDecreaseLiquidityResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPoolRequest({ value }: queryPoolRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolRequest", value: QueryPoolRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPoolsRequest({ value }: queryPoolsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolsRequest", value: QueryPoolsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPositionFeesRequest({ value }: queryPositionFeesRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionFeesRequest", value: QueryPositionFeesRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionFeesRequest: Could not create message: ' + e.message)
			}
		},
		
		pool({ value }: poolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.Pool", value: Pool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Pool: Could not create message: ' + e.message)
			}
		},
		
		eventCollectFees({ value }: eventCollectFeesParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventCollectFees", value: EventCollectFees.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventCollectFees: Could not create message: ' + e.message)
			}
		},
		
		poolInfo({ value }: poolInfoParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.PoolInfo", value: PoolInfo.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PoolInfo: Could not create message: ' + e.message)
			}
		},
		
		queryPoolResponse({ value }: queryPoolResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolResponse", value: QueryPoolResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolResponse: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationCreatePositionResponse({ value }: queryCalculationCreatePositionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryCalculationCreatePositionResponse", value: QueryCalculationCreatePositionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationCreatePositionResponse: Could not create message: ' + e.message)
			}
		},
		
		accumulatorPosition({ value }: accumulatorPositionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.AccumulatorPosition", value: AccumulatorPosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AccumulatorPosition: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		eventSetPool({ value }: eventSetPoolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventSetPool", value: EventSetPool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSetPool: Could not create message: ' + e.message)
			}
		},
		
		queryPositionRequest({ value }: queryPositionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionRequest", value: QueryPositionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPositionsResponse({ value }: queryPositionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionsResponse", value: QueryPositionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePoolResponse({ value }: msgCreatePoolResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgCreatePoolResponse", value: MsgCreatePoolResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePoolResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPositionsRequest({ value }: queryPositionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionsRequest", value: QueryPositionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionsRequest: Could not create message: ' + e.message)
			}
		},
		
		accumulatorObject({ value }: accumulatorObjectParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.AccumulatorObject", value: AccumulatorObject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AccumulatorObject: Could not create message: ' + e.message)
			}
		},
		
		eventRemovePool({ value }: eventRemovePoolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventRemovePool", value: EventRemovePool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventRemovePool: Could not create message: ' + e.message)
			}
		},
		
		eventRemovePosition({ value }: eventRemovePositionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventRemovePosition", value: EventRemovePosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventRemovePosition: Could not create message: ' + e.message)
			}
		},
		
		queryPoolsResponse({ value }: queryPoolsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolsResponse", value: QueryPoolsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPositionResponse({ value }: queryPositionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionResponse", value: QueryPositionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAddressPositionsRequest({ value }: queryAddressPositionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryAddressPositionsRequest", value: QueryAddressPositionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAddressPositionsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAddressPositionsResponse({ value }: queryAddressPositionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryAddressPositionsResponse", value: QueryAddressPositionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAddressPositionsResponse: Could not create message: ' + e.message)
			}
		},
		
		tickInfo({ value }: tickInfoParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.TickInfo", value: TickInfo.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:TickInfo: Could not create message: ' + e.message)
			}
		},
		
		msgClaimRewardsResponse({ value }: msgClaimRewardsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgClaimRewardsResponse", value: MsgClaimRewardsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgClaimRewardsResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		msgIncreaseLiquidity({ value }: msgIncreaseLiquidityParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgIncreaseLiquidity", value: MsgIncreaseLiquidity.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgIncreaseLiquidity: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePositionResponse({ value }: msgCreatePositionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgCreatePositionResponse", value: MsgCreatePositionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePositionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationIncreaseLiquidityResponse({ value }: queryCalculationIncreaseLiquidityResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryCalculationIncreaseLiquidityResponse", value: QueryCalculationIncreaseLiquidityResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationIncreaseLiquidityResponse: Could not create message: ' + e.message)
			}
		},
		
		eventSetPosition({ value }: eventSetPositionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventSetPosition", value: EventSetPosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSetPosition: Could not create message: ' + e.message)
			}
		},
		
		queryPositionFeesResponse({ value }: queryPositionFeesResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPositionFeesResponse", value: QueryPositionFeesResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPositionFeesResponse: Could not create message: ' + e.message)
			}
		},
		
		position({ value }: positionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.Position", value: Position.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Position: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryPoolPositionsRequest({ value }: queryPoolPositionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolPositionsRequest", value: QueryPoolPositionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolPositionsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPoolPositionsResponse({ value }: queryPoolPositionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.QueryPoolPositionsResponse", value: QueryPoolPositionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoolPositionsResponse: Could not create message: ' + e.message)
			}
		},
		
		eventSwapExactAmountIn({ value }: eventSwapExactAmountInParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventSwapExactAmountIn", value: EventSwapExactAmountIn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSwapExactAmountIn: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePool({ value }: msgCreatePoolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgCreatePool", value: MsgCreatePool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePool: Could not create message: ' + e.message)
			}
		},
		
		positionInfo({ value }: positionInfoParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.PositionInfo", value: PositionInfo.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PositionInfo: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePosition({ value }: msgCreatePositionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgCreatePosition", value: MsgCreatePosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePosition: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		tickParams({ value }: tickParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.TickParams", value: TickParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:TickParams: Could not create message: ' + e.message)
			}
		},
		
		eventSwapExactAmountOut({ value }: eventSwapExactAmountOutParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.EventSwapExactAmountOut", value: EventSwapExactAmountOut.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSwapExactAmountOut: Could not create message: ' + e.message)
			}
		},
		
		msgIncreaseLiquidityResponse({ value }: msgIncreaseLiquidityResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.liquiditypool.MsgIncreaseLiquidityResponse", value: MsgIncreaseLiquidityResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgIncreaseLiquidityResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SunriseLiquiditypool: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;