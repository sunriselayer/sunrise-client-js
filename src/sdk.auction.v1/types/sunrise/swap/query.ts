// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: sunrise/swap/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import { IncomingInFlightPacket, OutgoingInFlightPacket } from "./in_flight_packet";
import { Params } from "./params";
import { Route, RouteResult } from "./route";

export const protobufPackage = "sunrise.swap";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryIncomingInFlightPacketRequest {
  srcPortId: string;
  srcChannelId: string;
  sequence: number;
}

export interface QueryIncomingInFlightPacketResponse {
  packet: IncomingInFlightPacket | undefined;
}

export interface QueryIncomingInFlightPacketsRequest {
  pagination: PageRequest | undefined;
}

export interface QueryIncomingInFlightPacketsResponse {
  packets: IncomingInFlightPacket[];
  pagination: PageResponse | undefined;
}

export interface QueryOutgoingInFlightPacketRequest {
  srcPortId: string;
  srcChannelId: string;
  sequence: number;
}

export interface QueryOutgoingInFlightPacketResponse {
  packet: OutgoingInFlightPacket | undefined;
}

export interface QueryOutgoingInFlightPacketsRequest {
  pagination: PageRequest | undefined;
}

export interface QueryOutgoingInFlightPacketsResponse {
  packets: OutgoingInFlightPacket[];
  pagination: PageResponse | undefined;
}

export interface QueryCalculationSwapExactAmountInRequest {
  hasInterfaceFee: boolean;
  route: Route | undefined;
  amountIn: string;
}

export interface QueryCalculationSwapExactAmountInResponse {
  result: RouteResult | undefined;
  interfaceProviderFee: string;
  amountOut: string;
}

export interface QueryCalculationSwapExactAmountOutRequest {
  hasInterfaceFee: boolean;
  route: Route | undefined;
  amountOut: string;
}

export interface QueryCalculationSwapExactAmountOutResponse {
  result: RouteResult | undefined;
  interfaceProviderFee: string;
  amountIn: string;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryIncomingInFlightPacketRequest(): QueryIncomingInFlightPacketRequest {
  return { srcPortId: "", srcChannelId: "", sequence: 0 };
}

export const QueryIncomingInFlightPacketRequest: MessageFns<QueryIncomingInFlightPacketRequest> = {
  encode(message: QueryIncomingInFlightPacketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcPortId !== "") {
      writer.uint32(10).string(message.srcPortId);
    }
    if (message.srcChannelId !== "") {
      writer.uint32(18).string(message.srcChannelId);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).uint64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIncomingInFlightPacketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIncomingInFlightPacketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.srcPortId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.srcChannelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIncomingInFlightPacketRequest {
    return {
      srcPortId: isSet(object.srcPortId) ? globalThis.String(object.srcPortId) : "",
      srcChannelId: isSet(object.srcChannelId) ? globalThis.String(object.srcChannelId) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
    };
  },

  toJSON(message: QueryIncomingInFlightPacketRequest): unknown {
    const obj: any = {};
    if (message.srcPortId !== "") {
      obj.srcPortId = message.srcPortId;
    }
    if (message.srcChannelId !== "") {
      obj.srcChannelId = message.srcChannelId;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIncomingInFlightPacketRequest>, I>>(
    base?: I,
  ): QueryIncomingInFlightPacketRequest {
    return QueryIncomingInFlightPacketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIncomingInFlightPacketRequest>, I>>(
    object: I,
  ): QueryIncomingInFlightPacketRequest {
    const message = createBaseQueryIncomingInFlightPacketRequest();
    message.srcPortId = object.srcPortId ?? "";
    message.srcChannelId = object.srcChannelId ?? "";
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBaseQueryIncomingInFlightPacketResponse(): QueryIncomingInFlightPacketResponse {
  return { packet: undefined };
}

export const QueryIncomingInFlightPacketResponse: MessageFns<QueryIncomingInFlightPacketResponse> = {
  encode(message: QueryIncomingInFlightPacketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packet !== undefined) {
      IncomingInFlightPacket.encode(message.packet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIncomingInFlightPacketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIncomingInFlightPacketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packet = IncomingInFlightPacket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIncomingInFlightPacketResponse {
    return { packet: isSet(object.packet) ? IncomingInFlightPacket.fromJSON(object.packet) : undefined };
  },

  toJSON(message: QueryIncomingInFlightPacketResponse): unknown {
    const obj: any = {};
    if (message.packet !== undefined) {
      obj.packet = IncomingInFlightPacket.toJSON(message.packet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIncomingInFlightPacketResponse>, I>>(
    base?: I,
  ): QueryIncomingInFlightPacketResponse {
    return QueryIncomingInFlightPacketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIncomingInFlightPacketResponse>, I>>(
    object: I,
  ): QueryIncomingInFlightPacketResponse {
    const message = createBaseQueryIncomingInFlightPacketResponse();
    message.packet = (object.packet !== undefined && object.packet !== null)
      ? IncomingInFlightPacket.fromPartial(object.packet)
      : undefined;
    return message;
  },
};

function createBaseQueryIncomingInFlightPacketsRequest(): QueryIncomingInFlightPacketsRequest {
  return { pagination: undefined };
}

export const QueryIncomingInFlightPacketsRequest: MessageFns<QueryIncomingInFlightPacketsRequest> = {
  encode(message: QueryIncomingInFlightPacketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIncomingInFlightPacketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIncomingInFlightPacketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIncomingInFlightPacketsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryIncomingInFlightPacketsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIncomingInFlightPacketsRequest>, I>>(
    base?: I,
  ): QueryIncomingInFlightPacketsRequest {
    return QueryIncomingInFlightPacketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIncomingInFlightPacketsRequest>, I>>(
    object: I,
  ): QueryIncomingInFlightPacketsRequest {
    const message = createBaseQueryIncomingInFlightPacketsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIncomingInFlightPacketsResponse(): QueryIncomingInFlightPacketsResponse {
  return { packets: [], pagination: undefined };
}

export const QueryIncomingInFlightPacketsResponse: MessageFns<QueryIncomingInFlightPacketsResponse> = {
  encode(message: QueryIncomingInFlightPacketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packets) {
      IncomingInFlightPacket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIncomingInFlightPacketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIncomingInFlightPacketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packets.push(IncomingInFlightPacket.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIncomingInFlightPacketsResponse {
    return {
      packets: globalThis.Array.isArray(object?.packets)
        ? object.packets.map((e: any) => IncomingInFlightPacket.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryIncomingInFlightPacketsResponse): unknown {
    const obj: any = {};
    if (message.packets?.length) {
      obj.packets = message.packets.map((e) => IncomingInFlightPacket.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIncomingInFlightPacketsResponse>, I>>(
    base?: I,
  ): QueryIncomingInFlightPacketsResponse {
    return QueryIncomingInFlightPacketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIncomingInFlightPacketsResponse>, I>>(
    object: I,
  ): QueryIncomingInFlightPacketsResponse {
    const message = createBaseQueryIncomingInFlightPacketsResponse();
    message.packets = object.packets?.map((e) => IncomingInFlightPacket.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOutgoingInFlightPacketRequest(): QueryOutgoingInFlightPacketRequest {
  return { srcPortId: "", srcChannelId: "", sequence: 0 };
}

export const QueryOutgoingInFlightPacketRequest: MessageFns<QueryOutgoingInFlightPacketRequest> = {
  encode(message: QueryOutgoingInFlightPacketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcPortId !== "") {
      writer.uint32(10).string(message.srcPortId);
    }
    if (message.srcChannelId !== "") {
      writer.uint32(18).string(message.srcChannelId);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).uint64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutgoingInFlightPacketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutgoingInFlightPacketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.srcPortId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.srcChannelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutgoingInFlightPacketRequest {
    return {
      srcPortId: isSet(object.srcPortId) ? globalThis.String(object.srcPortId) : "",
      srcChannelId: isSet(object.srcChannelId) ? globalThis.String(object.srcChannelId) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
    };
  },

  toJSON(message: QueryOutgoingInFlightPacketRequest): unknown {
    const obj: any = {};
    if (message.srcPortId !== "") {
      obj.srcPortId = message.srcPortId;
    }
    if (message.srcChannelId !== "") {
      obj.srcChannelId = message.srcChannelId;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketRequest>, I>>(
    base?: I,
  ): QueryOutgoingInFlightPacketRequest {
    return QueryOutgoingInFlightPacketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketRequest>, I>>(
    object: I,
  ): QueryOutgoingInFlightPacketRequest {
    const message = createBaseQueryOutgoingInFlightPacketRequest();
    message.srcPortId = object.srcPortId ?? "";
    message.srcChannelId = object.srcChannelId ?? "";
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBaseQueryOutgoingInFlightPacketResponse(): QueryOutgoingInFlightPacketResponse {
  return { packet: undefined };
}

export const QueryOutgoingInFlightPacketResponse: MessageFns<QueryOutgoingInFlightPacketResponse> = {
  encode(message: QueryOutgoingInFlightPacketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packet !== undefined) {
      OutgoingInFlightPacket.encode(message.packet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutgoingInFlightPacketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutgoingInFlightPacketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packet = OutgoingInFlightPacket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutgoingInFlightPacketResponse {
    return { packet: isSet(object.packet) ? OutgoingInFlightPacket.fromJSON(object.packet) : undefined };
  },

  toJSON(message: QueryOutgoingInFlightPacketResponse): unknown {
    const obj: any = {};
    if (message.packet !== undefined) {
      obj.packet = OutgoingInFlightPacket.toJSON(message.packet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketResponse>, I>>(
    base?: I,
  ): QueryOutgoingInFlightPacketResponse {
    return QueryOutgoingInFlightPacketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketResponse>, I>>(
    object: I,
  ): QueryOutgoingInFlightPacketResponse {
    const message = createBaseQueryOutgoingInFlightPacketResponse();
    message.packet = (object.packet !== undefined && object.packet !== null)
      ? OutgoingInFlightPacket.fromPartial(object.packet)
      : undefined;
    return message;
  },
};

function createBaseQueryOutgoingInFlightPacketsRequest(): QueryOutgoingInFlightPacketsRequest {
  return { pagination: undefined };
}

export const QueryOutgoingInFlightPacketsRequest: MessageFns<QueryOutgoingInFlightPacketsRequest> = {
  encode(message: QueryOutgoingInFlightPacketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutgoingInFlightPacketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutgoingInFlightPacketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutgoingInFlightPacketsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryOutgoingInFlightPacketsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketsRequest>, I>>(
    base?: I,
  ): QueryOutgoingInFlightPacketsRequest {
    return QueryOutgoingInFlightPacketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketsRequest>, I>>(
    object: I,
  ): QueryOutgoingInFlightPacketsRequest {
    const message = createBaseQueryOutgoingInFlightPacketsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOutgoingInFlightPacketsResponse(): QueryOutgoingInFlightPacketsResponse {
  return { packets: [], pagination: undefined };
}

export const QueryOutgoingInFlightPacketsResponse: MessageFns<QueryOutgoingInFlightPacketsResponse> = {
  encode(message: QueryOutgoingInFlightPacketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packets) {
      OutgoingInFlightPacket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutgoingInFlightPacketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutgoingInFlightPacketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packets.push(OutgoingInFlightPacket.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutgoingInFlightPacketsResponse {
    return {
      packets: globalThis.Array.isArray(object?.packets)
        ? object.packets.map((e: any) => OutgoingInFlightPacket.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryOutgoingInFlightPacketsResponse): unknown {
    const obj: any = {};
    if (message.packets?.length) {
      obj.packets = message.packets.map((e) => OutgoingInFlightPacket.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketsResponse>, I>>(
    base?: I,
  ): QueryOutgoingInFlightPacketsResponse {
    return QueryOutgoingInFlightPacketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOutgoingInFlightPacketsResponse>, I>>(
    object: I,
  ): QueryOutgoingInFlightPacketsResponse {
    const message = createBaseQueryOutgoingInFlightPacketsResponse();
    message.packets = object.packets?.map((e) => OutgoingInFlightPacket.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryCalculationSwapExactAmountInRequest(): QueryCalculationSwapExactAmountInRequest {
  return { hasInterfaceFee: false, route: undefined, amountIn: "" };
}

export const QueryCalculationSwapExactAmountInRequest: MessageFns<QueryCalculationSwapExactAmountInRequest> = {
  encode(message: QueryCalculationSwapExactAmountInRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasInterfaceFee !== false) {
      writer.uint32(8).bool(message.hasInterfaceFee);
    }
    if (message.route !== undefined) {
      Route.encode(message.route, writer.uint32(18).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationSwapExactAmountInRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationSwapExactAmountInRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasInterfaceFee = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route = Route.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationSwapExactAmountInRequest {
    return {
      hasInterfaceFee: isSet(object.hasInterfaceFee) ? globalThis.Boolean(object.hasInterfaceFee) : false,
      route: isSet(object.route) ? Route.fromJSON(object.route) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
    };
  },

  toJSON(message: QueryCalculationSwapExactAmountInRequest): unknown {
    const obj: any = {};
    if (message.hasInterfaceFee !== false) {
      obj.hasInterfaceFee = message.hasInterfaceFee;
    }
    if (message.route !== undefined) {
      obj.route = Route.toJSON(message.route);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountInRequest>, I>>(
    base?: I,
  ): QueryCalculationSwapExactAmountInRequest {
    return QueryCalculationSwapExactAmountInRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountInRequest>, I>>(
    object: I,
  ): QueryCalculationSwapExactAmountInRequest {
    const message = createBaseQueryCalculationSwapExactAmountInRequest();
    message.hasInterfaceFee = object.hasInterfaceFee ?? false;
    message.route = (object.route !== undefined && object.route !== null) ? Route.fromPartial(object.route) : undefined;
    message.amountIn = object.amountIn ?? "";
    return message;
  },
};

function createBaseQueryCalculationSwapExactAmountInResponse(): QueryCalculationSwapExactAmountInResponse {
  return { result: undefined, interfaceProviderFee: "", amountOut: "" };
}

export const QueryCalculationSwapExactAmountInResponse: MessageFns<QueryCalculationSwapExactAmountInResponse> = {
  encode(message: QueryCalculationSwapExactAmountInResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      RouteResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.interfaceProviderFee !== "") {
      writer.uint32(18).string(message.interfaceProviderFee);
    }
    if (message.amountOut !== "") {
      writer.uint32(26).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationSwapExactAmountInResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationSwapExactAmountInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = RouteResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interfaceProviderFee = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationSwapExactAmountInResponse {
    return {
      result: isSet(object.result) ? RouteResult.fromJSON(object.result) : undefined,
      interfaceProviderFee: isSet(object.interfaceProviderFee) ? globalThis.String(object.interfaceProviderFee) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: QueryCalculationSwapExactAmountInResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RouteResult.toJSON(message.result);
    }
    if (message.interfaceProviderFee !== "") {
      obj.interfaceProviderFee = message.interfaceProviderFee;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountInResponse>, I>>(
    base?: I,
  ): QueryCalculationSwapExactAmountInResponse {
    return QueryCalculationSwapExactAmountInResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountInResponse>, I>>(
    object: I,
  ): QueryCalculationSwapExactAmountInResponse {
    const message = createBaseQueryCalculationSwapExactAmountInResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? RouteResult.fromPartial(object.result)
      : undefined;
    message.interfaceProviderFee = object.interfaceProviderFee ?? "";
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseQueryCalculationSwapExactAmountOutRequest(): QueryCalculationSwapExactAmountOutRequest {
  return { hasInterfaceFee: false, route: undefined, amountOut: "" };
}

export const QueryCalculationSwapExactAmountOutRequest: MessageFns<QueryCalculationSwapExactAmountOutRequest> = {
  encode(message: QueryCalculationSwapExactAmountOutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasInterfaceFee !== false) {
      writer.uint32(8).bool(message.hasInterfaceFee);
    }
    if (message.route !== undefined) {
      Route.encode(message.route, writer.uint32(18).fork()).join();
    }
    if (message.amountOut !== "") {
      writer.uint32(26).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationSwapExactAmountOutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationSwapExactAmountOutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasInterfaceFee = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route = Route.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationSwapExactAmountOutRequest {
    return {
      hasInterfaceFee: isSet(object.hasInterfaceFee) ? globalThis.Boolean(object.hasInterfaceFee) : false,
      route: isSet(object.route) ? Route.fromJSON(object.route) : undefined,
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: QueryCalculationSwapExactAmountOutRequest): unknown {
    const obj: any = {};
    if (message.hasInterfaceFee !== false) {
      obj.hasInterfaceFee = message.hasInterfaceFee;
    }
    if (message.route !== undefined) {
      obj.route = Route.toJSON(message.route);
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountOutRequest>, I>>(
    base?: I,
  ): QueryCalculationSwapExactAmountOutRequest {
    return QueryCalculationSwapExactAmountOutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountOutRequest>, I>>(
    object: I,
  ): QueryCalculationSwapExactAmountOutRequest {
    const message = createBaseQueryCalculationSwapExactAmountOutRequest();
    message.hasInterfaceFee = object.hasInterfaceFee ?? false;
    message.route = (object.route !== undefined && object.route !== null) ? Route.fromPartial(object.route) : undefined;
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseQueryCalculationSwapExactAmountOutResponse(): QueryCalculationSwapExactAmountOutResponse {
  return { result: undefined, interfaceProviderFee: "", amountIn: "" };
}

export const QueryCalculationSwapExactAmountOutResponse: MessageFns<QueryCalculationSwapExactAmountOutResponse> = {
  encode(message: QueryCalculationSwapExactAmountOutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      RouteResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.interfaceProviderFee !== "") {
      writer.uint32(18).string(message.interfaceProviderFee);
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationSwapExactAmountOutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationSwapExactAmountOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = RouteResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interfaceProviderFee = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationSwapExactAmountOutResponse {
    return {
      result: isSet(object.result) ? RouteResult.fromJSON(object.result) : undefined,
      interfaceProviderFee: isSet(object.interfaceProviderFee) ? globalThis.String(object.interfaceProviderFee) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
    };
  },

  toJSON(message: QueryCalculationSwapExactAmountOutResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RouteResult.toJSON(message.result);
    }
    if (message.interfaceProviderFee !== "") {
      obj.interfaceProviderFee = message.interfaceProviderFee;
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountOutResponse>, I>>(
    base?: I,
  ): QueryCalculationSwapExactAmountOutResponse {
    return QueryCalculationSwapExactAmountOutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationSwapExactAmountOutResponse>, I>>(
    object: I,
  ): QueryCalculationSwapExactAmountOutResponse {
    const message = createBaseQueryCalculationSwapExactAmountOutResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? RouteResult.fromPartial(object.result)
      : undefined;
    message.interfaceProviderFee = object.interfaceProviderFee ?? "";
    message.amountIn = object.amountIn ?? "";
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a list of IncomingInFlightPacket items. */
  IncomingInFlightPacket(request: QueryIncomingInFlightPacketRequest): Promise<QueryIncomingInFlightPacketResponse>;
  IncomingInFlightPackets(request: QueryIncomingInFlightPacketsRequest): Promise<QueryIncomingInFlightPacketsResponse>;
  /** Queries a list of OutgoingInFlightPacket items. */
  OutgoingInFlightPacket(request: QueryOutgoingInFlightPacketRequest): Promise<QueryOutgoingInFlightPacketResponse>;
  OutgoingInFlightPackets(request: QueryOutgoingInFlightPacketsRequest): Promise<QueryOutgoingInFlightPacketsResponse>;
  /** Queries a Calculation swap value. */
  CalculationSwapExactAmountIn(
    request: QueryCalculationSwapExactAmountInRequest,
  ): Promise<QueryCalculationSwapExactAmountInResponse>;
  CalculationSwapExactAmountOut(
    request: QueryCalculationSwapExactAmountOutRequest,
  ): Promise<QueryCalculationSwapExactAmountOutResponse>;
}

export const QueryServiceName = "sunrise.swap.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.IncomingInFlightPacket = this.IncomingInFlightPacket.bind(this);
    this.IncomingInFlightPackets = this.IncomingInFlightPackets.bind(this);
    this.OutgoingInFlightPacket = this.OutgoingInFlightPacket.bind(this);
    this.OutgoingInFlightPackets = this.OutgoingInFlightPackets.bind(this);
    this.CalculationSwapExactAmountIn = this.CalculationSwapExactAmountIn.bind(this);
    this.CalculationSwapExactAmountOut = this.CalculationSwapExactAmountOut.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  IncomingInFlightPacket(request: QueryIncomingInFlightPacketRequest): Promise<QueryIncomingInFlightPacketResponse> {
    const data = QueryIncomingInFlightPacketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IncomingInFlightPacket", data);
    return promise.then((data) => QueryIncomingInFlightPacketResponse.decode(new BinaryReader(data)));
  }

  IncomingInFlightPackets(request: QueryIncomingInFlightPacketsRequest): Promise<QueryIncomingInFlightPacketsResponse> {
    const data = QueryIncomingInFlightPacketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IncomingInFlightPackets", data);
    return promise.then((data) => QueryIncomingInFlightPacketsResponse.decode(new BinaryReader(data)));
  }

  OutgoingInFlightPacket(request: QueryOutgoingInFlightPacketRequest): Promise<QueryOutgoingInFlightPacketResponse> {
    const data = QueryOutgoingInFlightPacketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutgoingInFlightPacket", data);
    return promise.then((data) => QueryOutgoingInFlightPacketResponse.decode(new BinaryReader(data)));
  }

  OutgoingInFlightPackets(request: QueryOutgoingInFlightPacketsRequest): Promise<QueryOutgoingInFlightPacketsResponse> {
    const data = QueryOutgoingInFlightPacketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutgoingInFlightPackets", data);
    return promise.then((data) => QueryOutgoingInFlightPacketsResponse.decode(new BinaryReader(data)));
  }

  CalculationSwapExactAmountIn(
    request: QueryCalculationSwapExactAmountInRequest,
  ): Promise<QueryCalculationSwapExactAmountInResponse> {
    const data = QueryCalculationSwapExactAmountInRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CalculationSwapExactAmountIn", data);
    return promise.then((data) => QueryCalculationSwapExactAmountInResponse.decode(new BinaryReader(data)));
  }

  CalculationSwapExactAmountOut(
    request: QueryCalculationSwapExactAmountOutRequest,
  ): Promise<QueryCalculationSwapExactAmountOutResponse> {
    const data = QueryCalculationSwapExactAmountOutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CalculationSwapExactAmountOut", data);
    return promise.then((data) => QueryCalculationSwapExactAmountOutResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
