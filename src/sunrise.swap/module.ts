// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryOutgoingInFlightPacketResponse } from "./types/sunrise/swap/query";
import { QueryParamsResponse } from "./types/sunrise/swap/query";
import { QueryCalculationSwapExactAmountOutResponse } from "./types/sunrise/swap/query";
import { RouteParallel } from "./types/sunrise/swap/route";
import { Params } from "./types/sunrise/swap/params";
import { ExactAmountIn } from "./types/sunrise/swap/metadata";
import { RouteSeries } from "./types/sunrise/swap/route";
import { QueryOutgoingInFlightPacketsRequest } from "./types/sunrise/swap/query";
import { MsgSwapExactAmountOutResponse } from "./types/sunrise/swap/tx";
import { RouteResultParallel } from "./types/sunrise/swap/route";
import { ExactAmountOut } from "./types/sunrise/swap/metadata";
import { RoutePool } from "./types/sunrise/swap/route";
import { GenesisState } from "./types/sunrise/swap/genesis";
import { PacketMetadata } from "./types/sunrise/swap/metadata";
import { QueryParamsRequest } from "./types/sunrise/swap/query";
import { QueryCalculationSwapExactAmountInRequest } from "./types/sunrise/swap/query";
import { Route } from "./types/sunrise/swap/route";
import { QueryIncomingInFlightPacketRequest } from "./types/sunrise/swap/query";
import { QueryCalculationSwapExactAmountInResponse } from "./types/sunrise/swap/query";
import { RouteResult } from "./types/sunrise/swap/route";
import { MsgUpdateParams } from "./types/sunrise/swap/tx";
import { QueryOutgoingInFlightPacketRequest } from "./types/sunrise/swap/query";
import { MsgSwapExactAmountInResponse } from "./types/sunrise/swap/tx";
import { MsgSwapExactAmountOut } from "./types/sunrise/swap/tx";
import { RouteResultPool } from "./types/sunrise/swap/route";
import { ForwardMetadata } from "./types/sunrise/swap/metadata";
import { QueryIncomingInFlightPacketsRequest } from "./types/sunrise/swap/query";
import { IncomingInFlightPacket } from "./types/sunrise/swap/in_flight_packet";
import { QueryOutgoingInFlightPacketsResponse } from "./types/sunrise/swap/query";
import { QueryCalculationSwapExactAmountOutRequest } from "./types/sunrise/swap/query";
import { RouteResultSeries } from "./types/sunrise/swap/route";
import { QueryIncomingInFlightPacketsResponse } from "./types/sunrise/swap/query";
import { MsgSwapExactAmountIn } from "./types/sunrise/swap/tx";
import { PacketIndex } from "./types/sunrise/swap/in_flight_packet";
import { OutgoingInFlightPacket } from "./types/sunrise/swap/in_flight_packet";
import { SwapMetadata } from "./types/sunrise/swap/metadata";
import { QueryIncomingInFlightPacketResponse } from "./types/sunrise/swap/query";
import { MsgUpdateParamsResponse } from "./types/sunrise/swap/tx";


export { QueryOutgoingInFlightPacketResponse, QueryParamsResponse, QueryCalculationSwapExactAmountOutResponse, RouteParallel, Params, ExactAmountIn, RouteSeries, QueryOutgoingInFlightPacketsRequest, MsgSwapExactAmountOutResponse, RouteResultParallel, ExactAmountOut, RoutePool, GenesisState, PacketMetadata, QueryParamsRequest, QueryCalculationSwapExactAmountInRequest, Route, QueryIncomingInFlightPacketRequest, QueryCalculationSwapExactAmountInResponse, RouteResult, MsgUpdateParams, QueryOutgoingInFlightPacketRequest, MsgSwapExactAmountInResponse, MsgSwapExactAmountOut, RouteResultPool, ForwardMetadata, QueryIncomingInFlightPacketsRequest, IncomingInFlightPacket, QueryOutgoingInFlightPacketsResponse, QueryCalculationSwapExactAmountOutRequest, RouteResultSeries, QueryIncomingInFlightPacketsResponse, MsgSwapExactAmountIn, PacketIndex, OutgoingInFlightPacket, SwapMetadata, QueryIncomingInFlightPacketResponse, MsgUpdateParamsResponse };

type sendQueryOutgoingInFlightPacketResponseParams = {
  value: QueryOutgoingInFlightPacketResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationSwapExactAmountOutResponseParams = {
  value: QueryCalculationSwapExactAmountOutResponse,
  fee?: StdFee,
  memo?: string
};

type sendRouteParallelParams = {
  value: RouteParallel,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendExactAmountInParams = {
  value: ExactAmountIn,
  fee?: StdFee,
  memo?: string
};

type sendRouteSeriesParams = {
  value: RouteSeries,
  fee?: StdFee,
  memo?: string
};

type sendQueryOutgoingInFlightPacketsRequestParams = {
  value: QueryOutgoingInFlightPacketsRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgSwapExactAmountOutResponseParams = {
  value: MsgSwapExactAmountOutResponse,
  fee?: StdFee,
  memo?: string
};

type sendRouteResultParallelParams = {
  value: RouteResultParallel,
  fee?: StdFee,
  memo?: string
};

type sendExactAmountOutParams = {
  value: ExactAmountOut,
  fee?: StdFee,
  memo?: string
};

type sendRoutePoolParams = {
  value: RoutePool,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendPacketMetadataParams = {
  value: PacketMetadata,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationSwapExactAmountInRequestParams = {
  value: QueryCalculationSwapExactAmountInRequest,
  fee?: StdFee,
  memo?: string
};

type sendRouteParams = {
  value: Route,
  fee?: StdFee,
  memo?: string
};

type sendQueryIncomingInFlightPacketRequestParams = {
  value: QueryIncomingInFlightPacketRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationSwapExactAmountInResponseParams = {
  value: QueryCalculationSwapExactAmountInResponse,
  fee?: StdFee,
  memo?: string
};

type sendRouteResultParams = {
  value: RouteResult,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryOutgoingInFlightPacketRequestParams = {
  value: QueryOutgoingInFlightPacketRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgSwapExactAmountInResponseParams = {
  value: MsgSwapExactAmountInResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSwapExactAmountOutParams = {
  value: MsgSwapExactAmountOut,
  fee?: StdFee,
  memo?: string
};

type sendRouteResultPoolParams = {
  value: RouteResultPool,
  fee?: StdFee,
  memo?: string
};

type sendForwardMetadataParams = {
  value: ForwardMetadata,
  fee?: StdFee,
  memo?: string
};

type sendQueryIncomingInFlightPacketsRequestParams = {
  value: QueryIncomingInFlightPacketsRequest,
  fee?: StdFee,
  memo?: string
};

type sendIncomingInFlightPacketParams = {
  value: IncomingInFlightPacket,
  fee?: StdFee,
  memo?: string
};

type sendQueryOutgoingInFlightPacketsResponseParams = {
  value: QueryOutgoingInFlightPacketsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryCalculationSwapExactAmountOutRequestParams = {
  value: QueryCalculationSwapExactAmountOutRequest,
  fee?: StdFee,
  memo?: string
};

type sendRouteResultSeriesParams = {
  value: RouteResultSeries,
  fee?: StdFee,
  memo?: string
};

type sendQueryIncomingInFlightPacketsResponseParams = {
  value: QueryIncomingInFlightPacketsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSwapExactAmountInParams = {
  value: MsgSwapExactAmountIn,
  fee?: StdFee,
  memo?: string
};

type sendPacketIndexParams = {
  value: PacketIndex,
  fee?: StdFee,
  memo?: string
};

type sendOutgoingInFlightPacketParams = {
  value: OutgoingInFlightPacket,
  fee?: StdFee,
  memo?: string
};

type sendSwapMetadataParams = {
  value: SwapMetadata,
  fee?: StdFee,
  memo?: string
};

type sendQueryIncomingInFlightPacketResponseParams = {
  value: QueryIncomingInFlightPacketResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};


type queryOutgoingInFlightPacketResponseParams = {
  value: QueryOutgoingInFlightPacketResponse,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryCalculationSwapExactAmountOutResponseParams = {
  value: QueryCalculationSwapExactAmountOutResponse,
};

type routeParallelParams = {
  value: RouteParallel,
};

type paramsParams = {
  value: Params,
};

type exactAmountInParams = {
  value: ExactAmountIn,
};

type routeSeriesParams = {
  value: RouteSeries,
};

type queryOutgoingInFlightPacketsRequestParams = {
  value: QueryOutgoingInFlightPacketsRequest,
};

type msgSwapExactAmountOutResponseParams = {
  value: MsgSwapExactAmountOutResponse,
};

type routeResultParallelParams = {
  value: RouteResultParallel,
};

type exactAmountOutParams = {
  value: ExactAmountOut,
};

type routePoolParams = {
  value: RoutePool,
};

type genesisStateParams = {
  value: GenesisState,
};

type packetMetadataParams = {
  value: PacketMetadata,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryCalculationSwapExactAmountInRequestParams = {
  value: QueryCalculationSwapExactAmountInRequest,
};

type routeParams = {
  value: Route,
};

type queryIncomingInFlightPacketRequestParams = {
  value: QueryIncomingInFlightPacketRequest,
};

type queryCalculationSwapExactAmountInResponseParams = {
  value: QueryCalculationSwapExactAmountInResponse,
};

type routeResultParams = {
  value: RouteResult,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryOutgoingInFlightPacketRequestParams = {
  value: QueryOutgoingInFlightPacketRequest,
};

type msgSwapExactAmountInResponseParams = {
  value: MsgSwapExactAmountInResponse,
};

type msgSwapExactAmountOutParams = {
  value: MsgSwapExactAmountOut,
};

type routeResultPoolParams = {
  value: RouteResultPool,
};

type forwardMetadataParams = {
  value: ForwardMetadata,
};

type queryIncomingInFlightPacketsRequestParams = {
  value: QueryIncomingInFlightPacketsRequest,
};

type incomingInFlightPacketParams = {
  value: IncomingInFlightPacket,
};

type queryOutgoingInFlightPacketsResponseParams = {
  value: QueryOutgoingInFlightPacketsResponse,
};

type queryCalculationSwapExactAmountOutRequestParams = {
  value: QueryCalculationSwapExactAmountOutRequest,
};

type routeResultSeriesParams = {
  value: RouteResultSeries,
};

type queryIncomingInFlightPacketsResponseParams = {
  value: QueryIncomingInFlightPacketsResponse,
};

type msgSwapExactAmountInParams = {
  value: MsgSwapExactAmountIn,
};

type packetIndexParams = {
  value: PacketIndex,
};

type outgoingInFlightPacketParams = {
  value: OutgoingInFlightPacket,
};

type swapMetadataParams = {
  value: SwapMetadata,
};

type queryIncomingInFlightPacketResponseParams = {
  value: QueryIncomingInFlightPacketResponse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryOutgoingInFlightPacketResponse({ value, fee, memo }: sendQueryOutgoingInFlightPacketResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryOutgoingInFlightPacketResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryOutgoingInFlightPacketResponse({ value: QueryOutgoingInFlightPacketResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryOutgoingInFlightPacketResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationSwapExactAmountOutResponse({ value, fee, memo }: sendQueryCalculationSwapExactAmountOutResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationSwapExactAmountOutResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationSwapExactAmountOutResponse({ value: QueryCalculationSwapExactAmountOutResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationSwapExactAmountOutResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteParallel({ value, fee, memo }: sendRouteParallelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteParallel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeParallel({ value: RouteParallel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteParallel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendExactAmountIn({ value, fee, memo }: sendExactAmountInParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendExactAmountIn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.exactAmountIn({ value: ExactAmountIn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendExactAmountIn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteSeries({ value, fee, memo }: sendRouteSeriesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteSeries: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeSeries({ value: RouteSeries.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteSeries: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryOutgoingInFlightPacketsRequest({ value, fee, memo }: sendQueryOutgoingInFlightPacketsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryOutgoingInFlightPacketsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryOutgoingInFlightPacketsRequest({ value: QueryOutgoingInFlightPacketsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryOutgoingInFlightPacketsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSwapExactAmountOutResponse({ value, fee, memo }: sendMsgSwapExactAmountOutResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSwapExactAmountOutResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSwapExactAmountOutResponse({ value: MsgSwapExactAmountOutResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSwapExactAmountOutResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteResultParallel({ value, fee, memo }: sendRouteResultParallelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteResultParallel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeResultParallel({ value: RouteResultParallel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteResultParallel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendExactAmountOut({ value, fee, memo }: sendExactAmountOutParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendExactAmountOut: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.exactAmountOut({ value: ExactAmountOut.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendExactAmountOut: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRoutePool({ value, fee, memo }: sendRoutePoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRoutePool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routePool({ value: RoutePool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRoutePool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPacketMetadata({ value, fee, memo }: sendPacketMetadataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPacketMetadata: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.packetMetadata({ value: PacketMetadata.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPacketMetadata: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationSwapExactAmountInRequest({ value, fee, memo }: sendQueryCalculationSwapExactAmountInRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationSwapExactAmountInRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationSwapExactAmountInRequest({ value: QueryCalculationSwapExactAmountInRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationSwapExactAmountInRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRoute({ value, fee, memo }: sendRouteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRoute: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.route({ value: Route.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRoute: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryIncomingInFlightPacketRequest({ value, fee, memo }: sendQueryIncomingInFlightPacketRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryIncomingInFlightPacketRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryIncomingInFlightPacketRequest({ value: QueryIncomingInFlightPacketRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryIncomingInFlightPacketRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationSwapExactAmountInResponse({ value, fee, memo }: sendQueryCalculationSwapExactAmountInResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationSwapExactAmountInResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationSwapExactAmountInResponse({ value: QueryCalculationSwapExactAmountInResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationSwapExactAmountInResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteResult({ value, fee, memo }: sendRouteResultParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteResult: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeResult({ value: RouteResult.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteResult: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryOutgoingInFlightPacketRequest({ value, fee, memo }: sendQueryOutgoingInFlightPacketRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryOutgoingInFlightPacketRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryOutgoingInFlightPacketRequest({ value: QueryOutgoingInFlightPacketRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryOutgoingInFlightPacketRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSwapExactAmountInResponse({ value, fee, memo }: sendMsgSwapExactAmountInResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSwapExactAmountInResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSwapExactAmountInResponse({ value: MsgSwapExactAmountInResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSwapExactAmountInResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSwapExactAmountOut({ value, fee, memo }: sendMsgSwapExactAmountOutParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSwapExactAmountOut: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSwapExactAmountOut({ value: MsgSwapExactAmountOut.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSwapExactAmountOut: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteResultPool({ value, fee, memo }: sendRouteResultPoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteResultPool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeResultPool({ value: RouteResultPool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteResultPool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendForwardMetadata({ value, fee, memo }: sendForwardMetadataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendForwardMetadata: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.forwardMetadata({ value: ForwardMetadata.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendForwardMetadata: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryIncomingInFlightPacketsRequest({ value, fee, memo }: sendQueryIncomingInFlightPacketsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryIncomingInFlightPacketsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryIncomingInFlightPacketsRequest({ value: QueryIncomingInFlightPacketsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryIncomingInFlightPacketsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendIncomingInFlightPacket({ value, fee, memo }: sendIncomingInFlightPacketParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendIncomingInFlightPacket: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.incomingInFlightPacket({ value: IncomingInFlightPacket.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendIncomingInFlightPacket: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryOutgoingInFlightPacketsResponse({ value, fee, memo }: sendQueryOutgoingInFlightPacketsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryOutgoingInFlightPacketsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryOutgoingInFlightPacketsResponse({ value: QueryOutgoingInFlightPacketsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryOutgoingInFlightPacketsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryCalculationSwapExactAmountOutRequest({ value, fee, memo }: sendQueryCalculationSwapExactAmountOutRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryCalculationSwapExactAmountOutRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryCalculationSwapExactAmountOutRequest({ value: QueryCalculationSwapExactAmountOutRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryCalculationSwapExactAmountOutRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRouteResultSeries({ value, fee, memo }: sendRouteResultSeriesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRouteResultSeries: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.routeResultSeries({ value: RouteResultSeries.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRouteResultSeries: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryIncomingInFlightPacketsResponse({ value, fee, memo }: sendQueryIncomingInFlightPacketsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryIncomingInFlightPacketsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryIncomingInFlightPacketsResponse({ value: QueryIncomingInFlightPacketsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryIncomingInFlightPacketsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSwapExactAmountIn({ value, fee, memo }: sendMsgSwapExactAmountInParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSwapExactAmountIn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSwapExactAmountIn({ value: MsgSwapExactAmountIn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSwapExactAmountIn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPacketIndex({ value, fee, memo }: sendPacketIndexParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPacketIndex: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.packetIndex({ value: PacketIndex.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPacketIndex: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendOutgoingInFlightPacket({ value, fee, memo }: sendOutgoingInFlightPacketParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendOutgoingInFlightPacket: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.outgoingInFlightPacket({ value: OutgoingInFlightPacket.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendOutgoingInFlightPacket: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSwapMetadata({ value, fee, memo }: sendSwapMetadataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSwapMetadata: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.swapMetadata({ value: SwapMetadata.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSwapMetadata: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryIncomingInFlightPacketResponse({ value, fee, memo }: sendQueryIncomingInFlightPacketResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryIncomingInFlightPacketResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryIncomingInFlightPacketResponse({ value: QueryIncomingInFlightPacketResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryIncomingInFlightPacketResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryOutgoingInFlightPacketResponse({ value }: queryOutgoingInFlightPacketResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryOutgoingInFlightPacketResponse", value: QueryOutgoingInFlightPacketResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryOutgoingInFlightPacketResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationSwapExactAmountOutResponse({ value }: queryCalculationSwapExactAmountOutResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryCalculationSwapExactAmountOutResponse", value: QueryCalculationSwapExactAmountOutResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationSwapExactAmountOutResponse: Could not create message: ' + e.message)
			}
		},
		
		routeParallel({ value }: routeParallelParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteParallel", value: RouteParallel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteParallel: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		exactAmountIn({ value }: exactAmountInParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.ExactAmountIn", value: ExactAmountIn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ExactAmountIn: Could not create message: ' + e.message)
			}
		},
		
		routeSeries({ value }: routeSeriesParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteSeries", value: RouteSeries.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteSeries: Could not create message: ' + e.message)
			}
		},
		
		queryOutgoingInFlightPacketsRequest({ value }: queryOutgoingInFlightPacketsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryOutgoingInFlightPacketsRequest", value: QueryOutgoingInFlightPacketsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryOutgoingInFlightPacketsRequest: Could not create message: ' + e.message)
			}
		},
		
		msgSwapExactAmountOutResponse({ value }: msgSwapExactAmountOutResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgSwapExactAmountOutResponse", value: MsgSwapExactAmountOutResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSwapExactAmountOutResponse: Could not create message: ' + e.message)
			}
		},
		
		routeResultParallel({ value }: routeResultParallelParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteResultParallel", value: RouteResultParallel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteResultParallel: Could not create message: ' + e.message)
			}
		},
		
		exactAmountOut({ value }: exactAmountOutParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.ExactAmountOut", value: ExactAmountOut.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ExactAmountOut: Could not create message: ' + e.message)
			}
		},
		
		routePool({ value }: routePoolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RoutePool", value: RoutePool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RoutePool: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		packetMetadata({ value }: packetMetadataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.PacketMetadata", value: PacketMetadata.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PacketMetadata: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationSwapExactAmountInRequest({ value }: queryCalculationSwapExactAmountInRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryCalculationSwapExactAmountInRequest", value: QueryCalculationSwapExactAmountInRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationSwapExactAmountInRequest: Could not create message: ' + e.message)
			}
		},
		
		route({ value }: routeParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.Route", value: Route.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Route: Could not create message: ' + e.message)
			}
		},
		
		queryIncomingInFlightPacketRequest({ value }: queryIncomingInFlightPacketRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryIncomingInFlightPacketRequest", value: QueryIncomingInFlightPacketRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryIncomingInFlightPacketRequest: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationSwapExactAmountInResponse({ value }: queryCalculationSwapExactAmountInResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryCalculationSwapExactAmountInResponse", value: QueryCalculationSwapExactAmountInResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationSwapExactAmountInResponse: Could not create message: ' + e.message)
			}
		},
		
		routeResult({ value }: routeResultParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteResult", value: RouteResult.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteResult: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryOutgoingInFlightPacketRequest({ value }: queryOutgoingInFlightPacketRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryOutgoingInFlightPacketRequest", value: QueryOutgoingInFlightPacketRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryOutgoingInFlightPacketRequest: Could not create message: ' + e.message)
			}
		},
		
		msgSwapExactAmountInResponse({ value }: msgSwapExactAmountInResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgSwapExactAmountInResponse", value: MsgSwapExactAmountInResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSwapExactAmountInResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSwapExactAmountOut({ value }: msgSwapExactAmountOutParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgSwapExactAmountOut", value: MsgSwapExactAmountOut.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSwapExactAmountOut: Could not create message: ' + e.message)
			}
		},
		
		routeResultPool({ value }: routeResultPoolParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteResultPool", value: RouteResultPool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteResultPool: Could not create message: ' + e.message)
			}
		},
		
		forwardMetadata({ value }: forwardMetadataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.ForwardMetadata", value: ForwardMetadata.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ForwardMetadata: Could not create message: ' + e.message)
			}
		},
		
		queryIncomingInFlightPacketsRequest({ value }: queryIncomingInFlightPacketsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryIncomingInFlightPacketsRequest", value: QueryIncomingInFlightPacketsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryIncomingInFlightPacketsRequest: Could not create message: ' + e.message)
			}
		},
		
		incomingInFlightPacket({ value }: incomingInFlightPacketParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.IncomingInFlightPacket", value: IncomingInFlightPacket.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:IncomingInFlightPacket: Could not create message: ' + e.message)
			}
		},
		
		queryOutgoingInFlightPacketsResponse({ value }: queryOutgoingInFlightPacketsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryOutgoingInFlightPacketsResponse", value: QueryOutgoingInFlightPacketsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryOutgoingInFlightPacketsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryCalculationSwapExactAmountOutRequest({ value }: queryCalculationSwapExactAmountOutRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryCalculationSwapExactAmountOutRequest", value: QueryCalculationSwapExactAmountOutRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryCalculationSwapExactAmountOutRequest: Could not create message: ' + e.message)
			}
		},
		
		routeResultSeries({ value }: routeResultSeriesParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.RouteResultSeries", value: RouteResultSeries.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RouteResultSeries: Could not create message: ' + e.message)
			}
		},
		
		queryIncomingInFlightPacketsResponse({ value }: queryIncomingInFlightPacketsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryIncomingInFlightPacketsResponse", value: QueryIncomingInFlightPacketsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryIncomingInFlightPacketsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSwapExactAmountIn({ value }: msgSwapExactAmountInParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgSwapExactAmountIn", value: MsgSwapExactAmountIn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSwapExactAmountIn: Could not create message: ' + e.message)
			}
		},
		
		packetIndex({ value }: packetIndexParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.PacketIndex", value: PacketIndex.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PacketIndex: Could not create message: ' + e.message)
			}
		},
		
		outgoingInFlightPacket({ value }: outgoingInFlightPacketParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.OutgoingInFlightPacket", value: OutgoingInFlightPacket.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:OutgoingInFlightPacket: Could not create message: ' + e.message)
			}
		},
		
		swapMetadata({ value }: swapMetadataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.SwapMetadata", value: SwapMetadata.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SwapMetadata: Could not create message: ' + e.message)
			}
		},
		
		queryIncomingInFlightPacketResponse({ value }: queryIncomingInFlightPacketResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.QueryIncomingInFlightPacketResponse", value: QueryIncomingInFlightPacketResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryIncomingInFlightPacketResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.swap.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SunriseSwap: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;