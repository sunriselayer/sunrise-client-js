// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { Proof } from "./types/sunrise/da/published_data";
import { QueryAllPublishedDataResponse } from "./types/sunrise/da/query";
import { PublishedData } from "./types/sunrise/da/published_data";
import { QueryZkpProofThresholdRequest } from "./types/sunrise/da/query";
import { MsgSubmitProof } from "./types/sunrise/da/tx";
import { MsgChallengeForFraud } from "./types/sunrise/da/tx";
import { GenesisState } from "./types/sunrise/da/genesis";
import { Metadata } from "./types/sunrise/da/metadata";
import { MsgUpdateParamsResponse } from "./types/sunrise/da/tx";
import { MsgChallengeForFraudResponse } from "./types/sunrise/da/tx";
import { Params } from "./types/sunrise/da/params";
import { QueryAllPublishedDataRequest } from "./types/sunrise/da/query";
import { MsgPublishData } from "./types/sunrise/da/tx";
import { MsgSubmitProofResponse } from "./types/sunrise/da/tx";
import { VoteExtension } from "./types/sunrise/da/vote_extension";
import { MsgUpdateParams } from "./types/sunrise/da/tx";
import { QueryParamsResponse } from "./types/sunrise/da/query";
import { QueryPublishedDataRequest } from "./types/sunrise/da/query";
import { QueryZkpProofThresholdResponse } from "./types/sunrise/da/query";
import { MsgPublishDataResponse } from "./types/sunrise/da/tx";
import { QueryParamsRequest } from "./types/sunrise/da/query";
import { QueryPublishedDataResponse } from "./types/sunrise/da/query";


export { Proof, QueryAllPublishedDataResponse, PublishedData, QueryZkpProofThresholdRequest, MsgSubmitProof, MsgChallengeForFraud, GenesisState, Metadata, MsgUpdateParamsResponse, MsgChallengeForFraudResponse, Params, QueryAllPublishedDataRequest, MsgPublishData, MsgSubmitProofResponse, VoteExtension, MsgUpdateParams, QueryParamsResponse, QueryPublishedDataRequest, QueryZkpProofThresholdResponse, MsgPublishDataResponse, QueryParamsRequest, QueryPublishedDataResponse };

type sendProofParams = {
  value: Proof,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPublishedDataResponseParams = {
  value: QueryAllPublishedDataResponse,
  fee?: StdFee,
  memo?: string
};

type sendPublishedDataParams = {
  value: PublishedData,
  fee?: StdFee,
  memo?: string
};

type sendQueryZkpProofThresholdRequestParams = {
  value: QueryZkpProofThresholdRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubmitProofParams = {
  value: MsgSubmitProof,
  fee?: StdFee,
  memo?: string
};

type sendMsgChallengeForFraudParams = {
  value: MsgChallengeForFraud,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendMetadataParams = {
  value: Metadata,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgChallengeForFraudResponseParams = {
  value: MsgChallengeForFraudResponse,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPublishedDataRequestParams = {
  value: QueryAllPublishedDataRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgPublishDataParams = {
  value: MsgPublishData,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubmitProofResponseParams = {
  value: MsgSubmitProofResponse,
  fee?: StdFee,
  memo?: string
};

type sendVoteExtensionParams = {
  value: VoteExtension,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPublishedDataRequestParams = {
  value: QueryPublishedDataRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryZkpProofThresholdResponseParams = {
  value: QueryZkpProofThresholdResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgPublishDataResponseParams = {
  value: MsgPublishDataResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPublishedDataResponseParams = {
  value: QueryPublishedDataResponse,
  fee?: StdFee,
  memo?: string
};


type proofParams = {
  value: Proof,
};

type queryAllPublishedDataResponseParams = {
  value: QueryAllPublishedDataResponse,
};

type publishedDataParams = {
  value: PublishedData,
};

type queryZkpProofThresholdRequestParams = {
  value: QueryZkpProofThresholdRequest,
};

type msgSubmitProofParams = {
  value: MsgSubmitProof,
};

type msgChallengeForFraudParams = {
  value: MsgChallengeForFraud,
};

type genesisStateParams = {
  value: GenesisState,
};

type metadataParams = {
  value: Metadata,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgChallengeForFraudResponseParams = {
  value: MsgChallengeForFraudResponse,
};

type paramsParams = {
  value: Params,
};

type queryAllPublishedDataRequestParams = {
  value: QueryAllPublishedDataRequest,
};

type msgPublishDataParams = {
  value: MsgPublishData,
};

type msgSubmitProofResponseParams = {
  value: MsgSubmitProofResponse,
};

type voteExtensionParams = {
  value: VoteExtension,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryPublishedDataRequestParams = {
  value: QueryPublishedDataRequest,
};

type queryZkpProofThresholdResponseParams = {
  value: QueryZkpProofThresholdResponse,
};

type msgPublishDataResponseParams = {
  value: MsgPublishDataResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryPublishedDataResponseParams = {
  value: QueryPublishedDataResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendProof({ value, fee, memo }: sendProofParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProof: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.proof({ value: Proof.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProof: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPublishedDataResponse({ value, fee, memo }: sendQueryAllPublishedDataResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPublishedDataResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPublishedDataResponse({ value: QueryAllPublishedDataResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPublishedDataResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPublishedData({ value, fee, memo }: sendPublishedDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPublishedData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.publishedData({ value: PublishedData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPublishedData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZkpProofThresholdRequest({ value, fee, memo }: sendQueryZkpProofThresholdRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZkpProofThresholdRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZkpProofThresholdRequest({ value: QueryZkpProofThresholdRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZkpProofThresholdRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubmitProof({ value, fee, memo }: sendMsgSubmitProofParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubmitProof: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubmitProof({ value: MsgSubmitProof.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubmitProof: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgChallengeForFraud({ value, fee, memo }: sendMsgChallengeForFraudParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgChallengeForFraud: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgChallengeForFraud({ value: MsgChallengeForFraud.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgChallengeForFraud: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMetadata({ value, fee, memo }: sendMetadataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMetadata: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.metadata({ value: Metadata.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMetadata: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgChallengeForFraudResponse({ value, fee, memo }: sendMsgChallengeForFraudResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgChallengeForFraudResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgChallengeForFraudResponse({ value: MsgChallengeForFraudResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgChallengeForFraudResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPublishedDataRequest({ value, fee, memo }: sendQueryAllPublishedDataRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPublishedDataRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPublishedDataRequest({ value: QueryAllPublishedDataRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPublishedDataRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPublishData({ value, fee, memo }: sendMsgPublishDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPublishData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPublishData({ value: MsgPublishData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPublishData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubmitProofResponse({ value, fee, memo }: sendMsgSubmitProofResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubmitProofResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubmitProofResponse({ value: MsgSubmitProofResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubmitProofResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendVoteExtension({ value, fee, memo }: sendVoteExtensionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendVoteExtension: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.voteExtension({ value: VoteExtension.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendVoteExtension: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPublishedDataRequest({ value, fee, memo }: sendQueryPublishedDataRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPublishedDataRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPublishedDataRequest({ value: QueryPublishedDataRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPublishedDataRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZkpProofThresholdResponse({ value, fee, memo }: sendQueryZkpProofThresholdResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZkpProofThresholdResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZkpProofThresholdResponse({ value: QueryZkpProofThresholdResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZkpProofThresholdResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPublishDataResponse({ value, fee, memo }: sendMsgPublishDataResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPublishDataResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPublishDataResponse({ value: MsgPublishDataResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPublishDataResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPublishedDataResponse({ value, fee, memo }: sendQueryPublishedDataResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPublishedDataResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPublishedDataResponse({ value: QueryPublishedDataResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPublishedDataResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		proof({ value }: proofParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.Proof", value: Proof.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Proof: Could not create message: ' + e.message)
			}
		},
		
		queryAllPublishedDataResponse({ value }: queryAllPublishedDataResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryAllPublishedDataResponse", value: QueryAllPublishedDataResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPublishedDataResponse: Could not create message: ' + e.message)
			}
		},
		
		publishedData({ value }: publishedDataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.PublishedData", value: PublishedData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PublishedData: Could not create message: ' + e.message)
			}
		},
		
		queryZkpProofThresholdRequest({ value }: queryZkpProofThresholdRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryZkpProofThresholdRequest", value: QueryZkpProofThresholdRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZkpProofThresholdRequest: Could not create message: ' + e.message)
			}
		},
		
		msgSubmitProof({ value }: msgSubmitProofParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgSubmitProof", value: MsgSubmitProof.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubmitProof: Could not create message: ' + e.message)
			}
		},
		
		msgChallengeForFraud({ value }: msgChallengeForFraudParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgChallengeForFraud", value: MsgChallengeForFraud.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgChallengeForFraud: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		metadata({ value }: metadataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.Metadata", value: Metadata.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Metadata: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgChallengeForFraudResponse({ value }: msgChallengeForFraudResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgChallengeForFraudResponse", value: MsgChallengeForFraudResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgChallengeForFraudResponse: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryAllPublishedDataRequest({ value }: queryAllPublishedDataRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryAllPublishedDataRequest", value: QueryAllPublishedDataRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPublishedDataRequest: Could not create message: ' + e.message)
			}
		},
		
		msgPublishData({ value }: msgPublishDataParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgPublishData", value: MsgPublishData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPublishData: Could not create message: ' + e.message)
			}
		},
		
		msgSubmitProofResponse({ value }: msgSubmitProofResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgSubmitProofResponse", value: MsgSubmitProofResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubmitProofResponse: Could not create message: ' + e.message)
			}
		},
		
		voteExtension({ value }: voteExtensionParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.VoteExtension", value: VoteExtension.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:VoteExtension: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPublishedDataRequest({ value }: queryPublishedDataRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryPublishedDataRequest", value: QueryPublishedDataRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPublishedDataRequest: Could not create message: ' + e.message)
			}
		},
		
		queryZkpProofThresholdResponse({ value }: queryZkpProofThresholdResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryZkpProofThresholdResponse", value: QueryZkpProofThresholdResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZkpProofThresholdResponse: Could not create message: ' + e.message)
			}
		},
		
		msgPublishDataResponse({ value }: msgPublishDataResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.MsgPublishDataResponse", value: MsgPublishDataResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPublishDataResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPublishedDataResponse({ value }: queryPublishedDataResponseParams): EncodeObject {
			try {
				return { typeUrl: "/sunrise.da.QueryPublishedDataResponse", value: QueryPublishedDataResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPublishedDataResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SunriseDa: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;