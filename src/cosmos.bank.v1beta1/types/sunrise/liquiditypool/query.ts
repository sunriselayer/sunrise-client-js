// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: sunrise/liquiditypool/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { Params } from "./params";
import { Pool } from "./pool";
import { Position } from "./position";

export const protobufPackage = "sunrise.liquiditypool";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryPoolRequest {
  id: number;
}

export interface PoolInfo {
  pool: Pool | undefined;
  tokenBase: Coin | undefined;
  tokenQuote: Coin | undefined;
}

export interface QueryPoolResponse {
  pool: PoolInfo | undefined;
}

export interface QueryPoolsRequest {
  pagination: PageRequest | undefined;
}

export interface QueryPoolsResponse {
  pools: PoolInfo[];
  pagination: PageResponse | undefined;
}

export interface QueryPositionRequest {
  id: number;
}

export interface PositionInfo {
  position: Position | undefined;
  tokenBase: Coin | undefined;
  tokenQuote: Coin | undefined;
}

export interface QueryPositionResponse {
  position: PositionInfo | undefined;
}

export interface QueryPositionsRequest {
  pagination: PageRequest | undefined;
}

export interface QueryPositionsResponse {
  positions: PositionInfo[];
  pagination: PageResponse | undefined;
}

export interface QueryPoolPositionsRequest {
  poolId: number;
}

export interface QueryPoolPositionsResponse {
  positions: PositionInfo[];
}

export interface QueryAddressPositionsRequest {
  address: string;
}

export interface QueryAddressPositionsResponse {
  positions: PositionInfo[];
}

export interface QueryPositionFeesRequest {
  id: number;
}

export interface QueryPositionFeesResponse {
  fees: Coin[];
}

export interface QueryCalculationCreatePositionRequest {
  poolId: number;
  lowerTick: string;
  upperTick: string;
  amount: string;
  denom: string;
}

export interface QueryCalculationCreatePositionResponse {
  amount: Coin | undefined;
}

export interface QueryCalculationIncreaseLiquidityRequest {
  id: number;
  amountIn: string;
  denomIn: string;
}

export interface QueryCalculationIncreaseLiquidityResponse {
  tokenRequired: Coin | undefined;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryPoolRequest(): QueryPoolRequest {
  return { id: 0 };
}

export const QueryPoolRequest: MessageFns<QueryPoolRequest> = {
  encode(message: QueryPoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QueryPoolRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolRequest>, I>>(base?: I): QueryPoolRequest {
    return QueryPoolRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolRequest>, I>>(object: I): QueryPoolRequest {
    const message = createBaseQueryPoolRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBasePoolInfo(): PoolInfo {
  return { pool: undefined, tokenBase: undefined, tokenQuote: undefined };
}

export const PoolInfo: MessageFns<PoolInfo> = {
  encode(message: PoolInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pool !== undefined) {
      Pool.encode(message.pool, writer.uint32(10).fork()).join();
    }
    if (message.tokenBase !== undefined) {
      Coin.encode(message.tokenBase, writer.uint32(18).fork()).join();
    }
    if (message.tokenQuote !== undefined) {
      Coin.encode(message.tokenQuote, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PoolInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoolInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pool = Pool.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenBase = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenQuote = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PoolInfo {
    return {
      pool: isSet(object.pool) ? Pool.fromJSON(object.pool) : undefined,
      tokenBase: isSet(object.tokenBase) ? Coin.fromJSON(object.tokenBase) : undefined,
      tokenQuote: isSet(object.tokenQuote) ? Coin.fromJSON(object.tokenQuote) : undefined,
    };
  },

  toJSON(message: PoolInfo): unknown {
    const obj: any = {};
    if (message.pool !== undefined) {
      obj.pool = Pool.toJSON(message.pool);
    }
    if (message.tokenBase !== undefined) {
      obj.tokenBase = Coin.toJSON(message.tokenBase);
    }
    if (message.tokenQuote !== undefined) {
      obj.tokenQuote = Coin.toJSON(message.tokenQuote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PoolInfo>, I>>(base?: I): PoolInfo {
    return PoolInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PoolInfo>, I>>(object: I): PoolInfo {
    const message = createBasePoolInfo();
    message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
    message.tokenBase = (object.tokenBase !== undefined && object.tokenBase !== null)
      ? Coin.fromPartial(object.tokenBase)
      : undefined;
    message.tokenQuote = (object.tokenQuote !== undefined && object.tokenQuote !== null)
      ? Coin.fromPartial(object.tokenQuote)
      : undefined;
    return message;
  },
};

function createBaseQueryPoolResponse(): QueryPoolResponse {
  return { pool: undefined };
}

export const QueryPoolResponse: MessageFns<QueryPoolResponse> = {
  encode(message: QueryPoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pool !== undefined) {
      PoolInfo.encode(message.pool, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pool = PoolInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolResponse {
    return { pool: isSet(object.pool) ? PoolInfo.fromJSON(object.pool) : undefined };
  },

  toJSON(message: QueryPoolResponse): unknown {
    const obj: any = {};
    if (message.pool !== undefined) {
      obj.pool = PoolInfo.toJSON(message.pool);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolResponse>, I>>(base?: I): QueryPoolResponse {
    return QueryPoolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolResponse>, I>>(object: I): QueryPoolResponse {
    const message = createBaseQueryPoolResponse();
    message.pool = (object.pool !== undefined && object.pool !== null) ? PoolInfo.fromPartial(object.pool) : undefined;
    return message;
  },
};

function createBaseQueryPoolsRequest(): QueryPoolsRequest {
  return { pagination: undefined };
}

export const QueryPoolsRequest: MessageFns<QueryPoolsRequest> = {
  encode(message: QueryPoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryPoolsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolsRequest>, I>>(base?: I): QueryPoolsRequest {
    return QueryPoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolsRequest>, I>>(object: I): QueryPoolsRequest {
    const message = createBaseQueryPoolsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPoolsResponse(): QueryPoolsResponse {
  return { pools: [], pagination: undefined };
}

export const QueryPoolsResponse: MessageFns<QueryPoolsResponse> = {
  encode(message: QueryPoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pools) {
      PoolInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pools.push(PoolInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolsResponse {
    return {
      pools: globalThis.Array.isArray(object?.pools) ? object.pools.map((e: any) => PoolInfo.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPoolsResponse): unknown {
    const obj: any = {};
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => PoolInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolsResponse>, I>>(base?: I): QueryPoolsResponse {
    return QueryPoolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolsResponse>, I>>(object: I): QueryPoolsResponse {
    const message = createBaseQueryPoolsResponse();
    message.pools = object.pools?.map((e) => PoolInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPositionRequest(): QueryPositionRequest {
  return { id: 0 };
}

export const QueryPositionRequest: MessageFns<QueryPositionRequest> = {
  encode(message: QueryPositionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QueryPositionRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionRequest>, I>>(base?: I): QueryPositionRequest {
    return QueryPositionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionRequest>, I>>(object: I): QueryPositionRequest {
    const message = createBaseQueryPositionRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBasePositionInfo(): PositionInfo {
  return { position: undefined, tokenBase: undefined, tokenQuote: undefined };
}

export const PositionInfo: MessageFns<PositionInfo> = {
  encode(message: PositionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.tokenBase !== undefined) {
      Coin.encode(message.tokenBase, writer.uint32(18).fork()).join();
    }
    if (message.tokenQuote !== undefined) {
      Coin.encode(message.tokenQuote, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenBase = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenQuote = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PositionInfo {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      tokenBase: isSet(object.tokenBase) ? Coin.fromJSON(object.tokenBase) : undefined,
      tokenQuote: isSet(object.tokenQuote) ? Coin.fromJSON(object.tokenQuote) : undefined,
    };
  },

  toJSON(message: PositionInfo): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.tokenBase !== undefined) {
      obj.tokenBase = Coin.toJSON(message.tokenBase);
    }
    if (message.tokenQuote !== undefined) {
      obj.tokenQuote = Coin.toJSON(message.tokenQuote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PositionInfo>, I>>(base?: I): PositionInfo {
    return PositionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PositionInfo>, I>>(object: I): PositionInfo {
    const message = createBasePositionInfo();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.tokenBase = (object.tokenBase !== undefined && object.tokenBase !== null)
      ? Coin.fromPartial(object.tokenBase)
      : undefined;
    message.tokenQuote = (object.tokenQuote !== undefined && object.tokenQuote !== null)
      ? Coin.fromPartial(object.tokenQuote)
      : undefined;
    return message;
  },
};

function createBaseQueryPositionResponse(): QueryPositionResponse {
  return { position: undefined };
}

export const QueryPositionResponse: MessageFns<QueryPositionResponse> = {
  encode(message: QueryPositionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      PositionInfo.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = PositionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionResponse {
    return { position: isSet(object.position) ? PositionInfo.fromJSON(object.position) : undefined };
  },

  toJSON(message: QueryPositionResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = PositionInfo.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionResponse>, I>>(base?: I): QueryPositionResponse {
    return QueryPositionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionResponse>, I>>(object: I): QueryPositionResponse {
    const message = createBaseQueryPositionResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? PositionInfo.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseQueryPositionsRequest(): QueryPositionsRequest {
  return { pagination: undefined };
}

export const QueryPositionsRequest: MessageFns<QueryPositionsRequest> = {
  encode(message: QueryPositionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryPositionsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionsRequest>, I>>(base?: I): QueryPositionsRequest {
    return QueryPositionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionsRequest>, I>>(object: I): QueryPositionsRequest {
    const message = createBaseQueryPositionsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPositionsResponse(): QueryPositionsResponse {
  return { positions: [], pagination: undefined };
}

export const QueryPositionsResponse: MessageFns<QueryPositionsResponse> = {
  encode(message: QueryPositionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.positions) {
      PositionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positions.push(PositionInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionsResponse {
    return {
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => PositionInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPositionsResponse): unknown {
    const obj: any = {};
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => PositionInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionsResponse>, I>>(base?: I): QueryPositionsResponse {
    return QueryPositionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionsResponse>, I>>(object: I): QueryPositionsResponse {
    const message = createBaseQueryPositionsResponse();
    message.positions = object.positions?.map((e) => PositionInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPoolPositionsRequest(): QueryPoolPositionsRequest {
  return { poolId: 0 };
}

export const QueryPoolPositionsRequest: MessageFns<QueryPoolPositionsRequest> = {
  encode(message: QueryPoolPositionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.poolId !== 0) {
      writer.uint32(8).uint64(message.poolId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolPositionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.poolId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolPositionsRequest {
    return { poolId: isSet(object.poolId) ? globalThis.Number(object.poolId) : 0 };
  },

  toJSON(message: QueryPoolPositionsRequest): unknown {
    const obj: any = {};
    if (message.poolId !== 0) {
      obj.poolId = Math.round(message.poolId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolPositionsRequest>, I>>(base?: I): QueryPoolPositionsRequest {
    return QueryPoolPositionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolPositionsRequest>, I>>(object: I): QueryPoolPositionsRequest {
    const message = createBaseQueryPoolPositionsRequest();
    message.poolId = object.poolId ?? 0;
    return message;
  },
};

function createBaseQueryPoolPositionsResponse(): QueryPoolPositionsResponse {
  return { positions: [] };
}

export const QueryPoolPositionsResponse: MessageFns<QueryPoolPositionsResponse> = {
  encode(message: QueryPoolPositionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.positions) {
      PositionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPoolPositionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPoolPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positions.push(PositionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPoolPositionsResponse {
    return {
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => PositionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPoolPositionsResponse): unknown {
    const obj: any = {};
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => PositionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPoolPositionsResponse>, I>>(base?: I): QueryPoolPositionsResponse {
    return QueryPoolPositionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPoolPositionsResponse>, I>>(object: I): QueryPoolPositionsResponse {
    const message = createBaseQueryPoolPositionsResponse();
    message.positions = object.positions?.map((e) => PositionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAddressPositionsRequest(): QueryAddressPositionsRequest {
  return { address: "" };
}

export const QueryAddressPositionsRequest: MessageFns<QueryAddressPositionsRequest> = {
  encode(message: QueryAddressPositionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAddressPositionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressPositionsRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAddressPositionsRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressPositionsRequest>, I>>(base?: I): QueryAddressPositionsRequest {
    return QueryAddressPositionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressPositionsRequest>, I>>(object: I): QueryAddressPositionsRequest {
    const message = createBaseQueryAddressPositionsRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryAddressPositionsResponse(): QueryAddressPositionsResponse {
  return { positions: [] };
}

export const QueryAddressPositionsResponse: MessageFns<QueryAddressPositionsResponse> = {
  encode(message: QueryAddressPositionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.positions) {
      PositionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAddressPositionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positions.push(PositionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressPositionsResponse {
    return {
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => PositionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAddressPositionsResponse): unknown {
    const obj: any = {};
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => PositionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressPositionsResponse>, I>>(base?: I): QueryAddressPositionsResponse {
    return QueryAddressPositionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressPositionsResponse>, I>>(
    object: I,
  ): QueryAddressPositionsResponse {
    const message = createBaseQueryAddressPositionsResponse();
    message.positions = object.positions?.map((e) => PositionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPositionFeesRequest(): QueryPositionFeesRequest {
  return { id: 0 };
}

export const QueryPositionFeesRequest: MessageFns<QueryPositionFeesRequest> = {
  encode(message: QueryPositionFeesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionFeesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionFeesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionFeesRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QueryPositionFeesRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionFeesRequest>, I>>(base?: I): QueryPositionFeesRequest {
    return QueryPositionFeesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionFeesRequest>, I>>(object: I): QueryPositionFeesRequest {
    const message = createBaseQueryPositionFeesRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseQueryPositionFeesResponse(): QueryPositionFeesResponse {
  return { fees: [] };
}

export const QueryPositionFeesResponse: MessageFns<QueryPositionFeesResponse> = {
  encode(message: QueryPositionFeesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fees) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPositionFeesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionFeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fees.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPositionFeesResponse {
    return { fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: QueryPositionFeesResponse): unknown {
    const obj: any = {};
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPositionFeesResponse>, I>>(base?: I): QueryPositionFeesResponse {
    return QueryPositionFeesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPositionFeesResponse>, I>>(object: I): QueryPositionFeesResponse {
    const message = createBaseQueryPositionFeesResponse();
    message.fees = object.fees?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryCalculationCreatePositionRequest(): QueryCalculationCreatePositionRequest {
  return { poolId: 0, lowerTick: "", upperTick: "", amount: "", denom: "" };
}

export const QueryCalculationCreatePositionRequest: MessageFns<QueryCalculationCreatePositionRequest> = {
  encode(message: QueryCalculationCreatePositionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.poolId !== 0) {
      writer.uint32(8).uint64(message.poolId);
    }
    if (message.lowerTick !== "") {
      writer.uint32(18).string(message.lowerTick);
    }
    if (message.upperTick !== "") {
      writer.uint32(26).string(message.upperTick);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.denom !== "") {
      writer.uint32(42).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationCreatePositionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationCreatePositionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.poolId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lowerTick = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upperTick = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationCreatePositionRequest {
    return {
      poolId: isSet(object.poolId) ? globalThis.Number(object.poolId) : 0,
      lowerTick: isSet(object.lowerTick) ? globalThis.String(object.lowerTick) : "",
      upperTick: isSet(object.upperTick) ? globalThis.String(object.upperTick) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: QueryCalculationCreatePositionRequest): unknown {
    const obj: any = {};
    if (message.poolId !== 0) {
      obj.poolId = Math.round(message.poolId);
    }
    if (message.lowerTick !== "") {
      obj.lowerTick = message.lowerTick;
    }
    if (message.upperTick !== "") {
      obj.upperTick = message.upperTick;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationCreatePositionRequest>, I>>(
    base?: I,
  ): QueryCalculationCreatePositionRequest {
    return QueryCalculationCreatePositionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationCreatePositionRequest>, I>>(
    object: I,
  ): QueryCalculationCreatePositionRequest {
    const message = createBaseQueryCalculationCreatePositionRequest();
    message.poolId = object.poolId ?? 0;
    message.lowerTick = object.lowerTick ?? "";
    message.upperTick = object.upperTick ?? "";
    message.amount = object.amount ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryCalculationCreatePositionResponse(): QueryCalculationCreatePositionResponse {
  return { amount: undefined };
}

export const QueryCalculationCreatePositionResponse: MessageFns<QueryCalculationCreatePositionResponse> = {
  encode(message: QueryCalculationCreatePositionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationCreatePositionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationCreatePositionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationCreatePositionResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: QueryCalculationCreatePositionResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationCreatePositionResponse>, I>>(
    base?: I,
  ): QueryCalculationCreatePositionResponse {
    return QueryCalculationCreatePositionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationCreatePositionResponse>, I>>(
    object: I,
  ): QueryCalculationCreatePositionResponse {
    const message = createBaseQueryCalculationCreatePositionResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseQueryCalculationIncreaseLiquidityRequest(): QueryCalculationIncreaseLiquidityRequest {
  return { id: 0, amountIn: "", denomIn: "" };
}

export const QueryCalculationIncreaseLiquidityRequest: MessageFns<QueryCalculationIncreaseLiquidityRequest> = {
  encode(message: QueryCalculationIncreaseLiquidityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.amountIn !== "") {
      writer.uint32(18).string(message.amountIn);
    }
    if (message.denomIn !== "") {
      writer.uint32(26).string(message.denomIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationIncreaseLiquidityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationIncreaseLiquidityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.denomIn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationIncreaseLiquidityRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      denomIn: isSet(object.denomIn) ? globalThis.String(object.denomIn) : "",
    };
  },

  toJSON(message: QueryCalculationIncreaseLiquidityRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.denomIn !== "") {
      obj.denomIn = message.denomIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationIncreaseLiquidityRequest>, I>>(
    base?: I,
  ): QueryCalculationIncreaseLiquidityRequest {
    return QueryCalculationIncreaseLiquidityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationIncreaseLiquidityRequest>, I>>(
    object: I,
  ): QueryCalculationIncreaseLiquidityRequest {
    const message = createBaseQueryCalculationIncreaseLiquidityRequest();
    message.id = object.id ?? 0;
    message.amountIn = object.amountIn ?? "";
    message.denomIn = object.denomIn ?? "";
    return message;
  },
};

function createBaseQueryCalculationIncreaseLiquidityResponse(): QueryCalculationIncreaseLiquidityResponse {
  return { tokenRequired: undefined };
}

export const QueryCalculationIncreaseLiquidityResponse: MessageFns<QueryCalculationIncreaseLiquidityResponse> = {
  encode(message: QueryCalculationIncreaseLiquidityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenRequired !== undefined) {
      Coin.encode(message.tokenRequired, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCalculationIncreaseLiquidityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCalculationIncreaseLiquidityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenRequired = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCalculationIncreaseLiquidityResponse {
    return { tokenRequired: isSet(object.tokenRequired) ? Coin.fromJSON(object.tokenRequired) : undefined };
  },

  toJSON(message: QueryCalculationIncreaseLiquidityResponse): unknown {
    const obj: any = {};
    if (message.tokenRequired !== undefined) {
      obj.tokenRequired = Coin.toJSON(message.tokenRequired);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCalculationIncreaseLiquidityResponse>, I>>(
    base?: I,
  ): QueryCalculationIncreaseLiquidityResponse {
    return QueryCalculationIncreaseLiquidityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCalculationIncreaseLiquidityResponse>, I>>(
    object: I,
  ): QueryCalculationIncreaseLiquidityResponse {
    const message = createBaseQueryCalculationIncreaseLiquidityResponse();
    message.tokenRequired = (object.tokenRequired !== undefined && object.tokenRequired !== null)
      ? Coin.fromPartial(object.tokenRequired)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a list of Pool items. */
  Pool(request: QueryPoolRequest): Promise<QueryPoolResponse>;
  Pools(request: QueryPoolsRequest): Promise<QueryPoolsResponse>;
  /** Queries a list of Position items. */
  Position(request: QueryPositionRequest): Promise<QueryPositionResponse>;
  Positions(request: QueryPositionsRequest): Promise<QueryPositionsResponse>;
  PoolPositions(request: QueryPoolPositionsRequest): Promise<QueryPoolPositionsResponse>;
  AddressPositions(request: QueryAddressPositionsRequest): Promise<QueryAddressPositionsResponse>;
  /** Query fees by position id */
  PositionFees(request: QueryPositionFeesRequest): Promise<QueryPositionFeesResponse>;
  /** Query calculation another amount of create position */
  CalculationCreatePosition(
    request: QueryCalculationCreatePositionRequest,
  ): Promise<QueryCalculationCreatePositionResponse>;
  /** Query calculation another amount of increase liquidity */
  CalculationIncreaseLiquidity(
    request: QueryCalculationIncreaseLiquidityRequest,
  ): Promise<QueryCalculationIncreaseLiquidityResponse>;
}

export const QueryServiceName = "sunrise.liquiditypool.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.Pool = this.Pool.bind(this);
    this.Pools = this.Pools.bind(this);
    this.Position = this.Position.bind(this);
    this.Positions = this.Positions.bind(this);
    this.PoolPositions = this.PoolPositions.bind(this);
    this.AddressPositions = this.AddressPositions.bind(this);
    this.PositionFees = this.PositionFees.bind(this);
    this.CalculationCreatePosition = this.CalculationCreatePosition.bind(this);
    this.CalculationIncreaseLiquidity = this.CalculationIncreaseLiquidity.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  Pool(request: QueryPoolRequest): Promise<QueryPoolResponse> {
    const data = QueryPoolRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Pool", data);
    return promise.then((data) => QueryPoolResponse.decode(new BinaryReader(data)));
  }

  Pools(request: QueryPoolsRequest): Promise<QueryPoolsResponse> {
    const data = QueryPoolsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Pools", data);
    return promise.then((data) => QueryPoolsResponse.decode(new BinaryReader(data)));
  }

  Position(request: QueryPositionRequest): Promise<QueryPositionResponse> {
    const data = QueryPositionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Position", data);
    return promise.then((data) => QueryPositionResponse.decode(new BinaryReader(data)));
  }

  Positions(request: QueryPositionsRequest): Promise<QueryPositionsResponse> {
    const data = QueryPositionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Positions", data);
    return promise.then((data) => QueryPositionsResponse.decode(new BinaryReader(data)));
  }

  PoolPositions(request: QueryPoolPositionsRequest): Promise<QueryPoolPositionsResponse> {
    const data = QueryPoolPositionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PoolPositions", data);
    return promise.then((data) => QueryPoolPositionsResponse.decode(new BinaryReader(data)));
  }

  AddressPositions(request: QueryAddressPositionsRequest): Promise<QueryAddressPositionsResponse> {
    const data = QueryAddressPositionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddressPositions", data);
    return promise.then((data) => QueryAddressPositionsResponse.decode(new BinaryReader(data)));
  }

  PositionFees(request: QueryPositionFeesRequest): Promise<QueryPositionFeesResponse> {
    const data = QueryPositionFeesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PositionFees", data);
    return promise.then((data) => QueryPositionFeesResponse.decode(new BinaryReader(data)));
  }

  CalculationCreatePosition(
    request: QueryCalculationCreatePositionRequest,
  ): Promise<QueryCalculationCreatePositionResponse> {
    const data = QueryCalculationCreatePositionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CalculationCreatePosition", data);
    return promise.then((data) => QueryCalculationCreatePositionResponse.decode(new BinaryReader(data)));
  }

  CalculationIncreaseLiquidity(
    request: QueryCalculationIncreaseLiquidityRequest,
  ): Promise<QueryCalculationIncreaseLiquidityResponse> {
    const data = QueryCalculationIncreaseLiquidityRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CalculationIncreaseLiquidity", data);
    return promise.then((data) => QueryCalculationIncreaseLiquidityResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
